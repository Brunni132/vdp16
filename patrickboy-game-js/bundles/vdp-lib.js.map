{"version":3,"sources":["webpack://vdp-lib/webpack/universalModuleDefinition","webpack://vdp-lib/webpack/bootstrap","webpack://vdp-lib/external {\"root\":\"window\",\"commonjs\":\"gl-matrix\",\"commonjs2\":\"gl-matrix\",\"amd\":\"gl-matrix\"}","webpack://vdp-lib/./vdp/shaders.ts","webpack://vdp-lib/./vdp/utils.ts","webpack://vdp-lib/./vdp/sprites.ts","webpack://vdp-lib/./vdp/maps.ts","webpack://vdp-lib/./vdp/memory.ts","webpack://vdp-lib/./vdp/color32.ts","webpack://vdp-lib/./vdp/shadowtexture.ts","webpack://vdp-lib/./vdp/vdp.ts","webpack://vdp-lib/./vdp/generalpolys.ts","webpack://vdp-lib/./vdp/FramerateAdjuster.ts","webpack://vdp-lib/./vdp/runloop.ts","webpack://vdp-lib/./lib-main.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SCREEN_WIDTH","SCREEN_HEIGHT","PALETTE_TEX_W","MAP_TEX_W","MAP_TEX_H","SPRITE_TEX_W","SPRITE_TEX_H","PALETTE_TEX_H","SEMITRANSPARENT_CANVAS","OTHER_TEX_W","OTHER_TEX_H","DISCARD_ALPHA","PALETTE_HICOLOR_FLAG","envColor","declareReadTexel","paletteMultiplier8","paletteMultiplier4","makeOutputColor","colorExpr","OES_texture_float_ext","readPixelsFramebuffer","LoadedTexture","texture","image","this","width","height","loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","deleteShader","initShaderProgram","vsSource","fsSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","loadTexture","url","createTexture","Image","bindTexture","TEXTURE_2D","Promise","resolve","onload","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","REPEAT","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","src","makeBuffer","createBuffer","bindToFramebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","readFromTexture32","x","y","w","h","result","Uint8Array","readPixels","TEMP_MakeDualTriangle","array","stride","concat","apply","slice","OBJ_BUFFER_STRIDE","sprites_ObjBuffer","ObjBuffer","numVertices","usedVertices","xyzp","Float32Array","uv","maxVertices","computeUsedObjects","first","count","firstSprite","usedSprites","computeObjectCells","getSizeOfObject","firstVertice","getZOfObject","index","objectIndex","vert","Math","abs","limitObjList","maxCells","cells","endOfList","size","current","DEBUG","console","log","sort","frontToBack","_this","items","Array","from","length","v","k","a","b","originalXyzp","originalUv","set","subarray","max","ceil","makeObjBuffer","numSprites","BG_BUFFER_STRIDE","MapBuffer","mapInfo1","mapInfo2","mapInfo3","mapInfo4","drawPendingMap","vdp","mapBuffer","prog","mapProgram","bindBuffer","ARRAY_BUFFER","glBuffers","bufferData","STREAM_DRAW","useProgram","program","FLOAT","normalize","offset","vertexAttribPointer","attribLocations","enableVertexAttribArray","num","activeTexture","TEXTURE0","spriteTexture","TEXTURE1","paletteTexture","TEXTURE2","mapTexture","TEXTURE3","otherTexture","uniform1i","uniformLocations","uSamplerSprites","uSamplerPalettes","uSamplerMaps","uSamplerOthers","uniformMatrix4fv","projectionMatrix","uniformMatrix3fv","modelViewMatrix","uniform4f","drawArrays","TRIANGLES","makeMapBuffer","numMaps","VdpMap","designTileset","designPalette","offsetted","VdpPalette","VdpSprite","tw","th","tiles","hiColor","tile","no","columnsPerRow","floor","Error","col","row","Array2D","buffer","getElement","setElement","color32","extract","bitsPerComponent","posterize","g","make","extendColor12","reverseColor32","parse","charAt","parseInt","substring","hiBits","add","sub","mul","blend","factor","invF","min","shadowtexture_ShadowTexture","ShadowTexture","pixelsPerTexel","posterizeToBpp","clone","readToBuffer","texWidth","dst","setPosterization","bitsPerPixel","constructor","Uint32Array","writeTo","data","syncToVramTexture","tightlyPackedBuffer","texSubImage2D","VDPCopySource","vdp_TransparencyConfig","TransparencyConfig","effect","operation","blendSrc","blendDst","blendEquation","FUNC_REVERSE_SUBTRACT","FUNC_ADD","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","paletteBpp","blendColor","CONSTANT_COLOR","disable","vdp_LineTransformationArray","LineTransformationArray","getLine","lineNo","external_root_window_commonjs_gl_matrix_commonjs2_gl_matrix_amd_gl_matrix_","fromValues","setLine","transformation","NO_TRANSPARENCY","STANDARD_TRANSPARENCY","vdp_VDP","VDP","canvas","done","fadeColor","bgTransparency","objTransparency","bgBuffer","tbgBuffer","obj0Buffer","obj1Buffer","stats","peakOBJ0","peakOBJ1","peakBG","OBJ0Limit","frameStarted","nextLinescrollBuffer","_initContext","_initMatrices","fetch","then","res","ok","json","gameData","info","indexOf","sprites","tex","typed","romSpriteTex","shadowSpriteTex","palettes","romPaletteTex","shadowPaletteTex","maps","paletteTexW","paletteTexH","mapTexW","mapTexH","spriteTexW","spriteTexH","romMapTex","Uint16Array","shadowMapTex","getExtension","full","fill","createDataTextureFloat","configBDColor","getAttribLocation","getUniformLocation","spriteProgram","opaquePolyProgram","arrayBuffers","xy","TOTAL_VERTICES","color","configBGTransparency","opts","op","configFade","configOBJTransparency","drawBG","map","pal","_getPalette","palette","til","_getSprite","tileset","scrollX","scrollY","winX","winY","winW","winH","wrap","prio","transparent","usedLayers","linescrollBuffer","lineTransform","uMap","vMap","uTileset","vTileset","mapWidth","mapHeight","tilesetWidth","tileWidth","tileHeight","palNo","z","enqueueMap","drawObj","sprite","objBuffer","xStart","yStart","xEnd","yEnd","uStart","vStart","uEnd","vEnd","enqueueObj","getStats","pals","readMap","_getMap","rom","readPalette","readPaletteMemory","readSprite","spr","hicol","writeMap","writePalette","writePaletteMemory","writeSprite","_computeStats","obj0Limit","_totalUsedOBJ0","_totalUsedOBJ1","_doRender","clearColor","clearDepth","DEPTH_TEST","depthFunc","LESS","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","identity","_drawObjLayer","depthMask","objLimit","numObjectsToDraw","drawPendingObj","_endFrame","_a","colorR","colorG","colorB","colorA","positions","colors","TRIANGLE_STRIP","drawOpaquePoly","getContext","premultipliedAlpha","alpha","ortho","_startFrame","NOMINAL_FRAMERATE","MIN_ACCEPTABLE_DT","REGULAR_DT","MAX_ACCEPTABLE_DT","FramerateAdjuster","last","late","framerateSum","doForSmoothness","timestamp","diff","_timeDiff","_addToFramerate","skipFrames","doSimplest","doStandard","getFramerate","loadVdp","screenWidth","screenHeight","compositedFramebuffer","startGame","loadedCb","document","querySelector","coroutine","lastInt","times","framerateAdj","skippedFrames","renderedFrames","requestAnimationFrame","step","timestampInt","reduce","toFixed","toRender","framerate","before","performance","now","next","push","__webpack_exports__"],"mappings":"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","file":"vdp-lib.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gl-matrix\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"vdp-lib\", [\"gl-matrix\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vdp-lib\"] = factory(require(\"gl-matrix\"));\n\telse\n\t\troot[\"vdp-lib\"] = factory(root[\"window\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","export let SCREEN_WIDTH, SCREEN_HEIGHT;\nexport let MAP_TEX_W = 1024, MAP_TEX_H = 1024;\nexport let SPRITE_TEX_W = 1024, SPRITE_TEX_H = 1024;\nexport let PALETTE_TEX_W, PALETTE_TEX_H = 256;\nexport let SEMITRANSPARENT_CANVAS = false;\n\nexport const OTHER_TEX_W = 2048, OTHER_TEX_H = 16;\n\n// Used for limited machine\nexport const USE_PRIORITIES = true;\n// 4 on limited machine\nexport const MAX_BGS = 1;\n// True on limited machine, false otherwise\nexport const DISCARD_ALPHA = true;\n\nexport const MAX_SPRITES = 1 << 16;\n\nexport const PALETTE_HICOLOR_FLAG = 1 << 15;\n\nexport const envColor: number[] = [1, 1, 1, 1];\n\nexport function setParams(screenWidth: number, screenHeight: number, compositedFramebuffer: boolean = false) {\n\tSCREEN_WIDTH = screenWidth;\n\tSCREEN_HEIGHT = screenHeight;\n\tSEMITRANSPARENT_CANVAS = compositedFramebuffer;\n}\n\nexport function setTextureSizes(paletteTexW: number, paletteTexH: number, mapTexW: number, mapTexH: number, spriteTexW: number, spriteTexH: number) {\n\tPALETTE_TEX_H = paletteTexH;\n\tPALETTE_TEX_W = paletteTexW;\n\tSPRITE_TEX_W = spriteTexW;\n\tSPRITE_TEX_H = spriteTexH;\n\tMAP_TEX_W = mapTexW;\n\tMAP_TEX_H = mapTexH;\n}\n\nexport function declareReadTexel(): string {\n\tconst paletteMultiplier8 = `float(${(255.0 / 256.0) * (256 / PALETTE_TEX_W)})`;\n\tconst paletteMultiplier4 = `float(${16.0 / PALETTE_TEX_W / 16.0})`;\n\tconst byteMultiplier = '255.0';\n\t// Returns a value between 0 and 1, ready to map a color in palette (0..255)\n\treturn `\n\t\t\tfloat readTexel8(float x, float y) {\n\t\t\t\tint texelId = int(x / 4.0);\n\t\t\t\tvec4 read = texture2D(uSamplerSprites, vec2(float(texelId) / ${SPRITE_TEX_W}.0, y / ${SPRITE_TEX_H}.0));\n\t\t\t\tint texelC = int(x) - texelId * 4;\n\t\t\t\tif (texelC == 0) return read.r * ${paletteMultiplier8};\n\t\t\t\tif (texelC == 1) return read.g * ${paletteMultiplier8};\n\t\t\t\tif (texelC == 2) return read.b * ${paletteMultiplier8};\n\t\t\t\treturn read.a * ${paletteMultiplier8};\n\t\t\t}\n\t\t\t\n\t\t\tfloat extractTexelHi(float colorComp) {\n\t\t\t\tint intValue = int(colorComp * ${byteMultiplier});\n\t\t\t\treturn float(intValue / 16) * ${paletteMultiplier4};\n\t\t\t}\n\n\t\t\tfloat extractTexelLo(float colorComp) {\n\t\t\t\tint intValue = int(colorComp * ${byteMultiplier});\n\t\t\t\treturn float(intValue - (intValue / 16) * 16) * ${paletteMultiplier4};\n\t\t\t\t//return float(mod(float(intValue), 16.0)) * ${paletteMultiplier4};\n\t\t\t}\n\t\n\t\t\tfloat readTexel4(float x, float y) {\n\t\t\t\tint texelId = int(x / 8.0);\n\t\t\t\tvec4 read = texture2D(uSamplerSprites, vec2(float(texelId) / ${SPRITE_TEX_W}.0, y / ${SPRITE_TEX_H}.0));\n\t\t\t\tint texelC = int(x) - texelId * 8;\n\t\t\t\t\n\t\t\t\tif (texelC == 0) return extractTexelHi(read.r);\n\t\t\t\tif (texelC == 1) return extractTexelLo(read.r);\n\t\t\t\tif (texelC == 2) return extractTexelHi(read.g);\n\t\t\t\tif (texelC == 3) return extractTexelLo(read.g);\n\t\t\t\tif (texelC == 4) return extractTexelHi(read.b);\n\t\t\t\tif (texelC == 5) return extractTexelLo(read.b);\n\t\t\t\tif (texelC == 6) return extractTexelHi(read.a);\n\t\t\t\treturn extractTexelLo(read.a);\n\t\t\t\t//return 9.0 * ${paletteMultiplier4};\n\t\t\t}`;\n}\n\nexport function declareReadPalette(): string {\n\t// Can be reused, works and is checked to be 100% equivalent to having a RGBA4444 texture. But beware that makeOutputColor takes in account the envColor but doesn't posterize it, so you may want to move that\n\t// return `vec4 readPalette(float x, float y) {\n\t// \t\t\tvec4 data = texture2D(uSamplerPalettes, vec2(x, y));\n\t// \t\t\t// Checked: same render as pre-posterization\n\t// \t\t\treturn floor(data * 16.0) / 15.0;\n\t// \t\t}`;\n\n\t// Can be used to make more intense colors\n\t//return `vec4 readPalette(float x, float y) {\n\t//\t\t\tvec3 color = texture2D(uSamplerPalettes, vec2(x, y)).rgb;\n\t//\t\t\t//vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n\t//\t\t\tvec3 gray = vec3(dot(vec3(0.3,0.5,0.2), color));\n\t//\t\t\treturn vec4(mix(color, gray, -0.5), 1);\n\t//\t\t}`;\n\n\treturn `vec4 readPalette(float x, float y) {\n\t\t\t\treturn texture2D(uSamplerPalettes, vec2(x, y));\n\t\t\t}`;\n}\n\nexport function makeOutputColor(colorExpr: string): string {\n\tif (DISCARD_ALPHA) {\n\t\treturn `vec4((${colorExpr}).rgb * uEnvColor.rgb, 1)`;\n\t}\n\treturn `${colorExpr} * uEnvColor`;\n}\n","import { mat3, mat4, vec3 } from 'gl-matrix';\n\nlet OES_texture_float_ext: any = null;\nlet readPixelsFramebuffer: WebGLFramebuffer = null;\n\n/**\n * @param mat {mat3}\n * @returns {vec3}\n */\nexport function getScalingFactorOfMatrix(mat: mat3): vec3 {\n\tconst scaling = vec3.create();\n\tconst fullMat = mat4.fromValues(\n\t\tmat[0], mat[1], mat[2], 0,\n\t\tmat[3], mat[4], mat[5], 0,\n\t\tmat[6], mat[7], mat[8], 0,\n\t\t0, 0, 0, 1);\n\tmat4.getScaling(scaling, fullMat);\n\treturn scaling;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Texture\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nexport class LoadedTexture {\n\ttexture: WebGLTexture;\n\twidth: number;\n\theight: number;\n\n\tconstructor(texture: WebGLTexture, image: {width: number, height: number}) {\n\t\tthis.texture = texture;\n\t\tthis.width = image.width;\n\t\tthis.height = image.height;\n\t}\n}\n\n// export function createDataTexture8(gl, width, height) {\n// \tconst texture = gl.createTexture();\n// \tgl.bindTexture(gl.TEXTURE_2D, texture);\n// \t// const ext = gl.getExtension('WEBGL_depth_texture');\n// \t// alert(gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null));\n// \tif (width % 4 !== 0) alert(`createDataTexture8: ${width} MUST be mod 4`);\n// \tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width / 4, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n// \treturn texture;\n// }\n\n// If you're going to store 8 bits components for instance, divide the width by 4\nexport function createDataTexture32(gl: WebGLRenderingContext, width: number, height: number): WebGLTexture {\n\tconst texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\treturn texture;\n}\n\nexport function createDataTextureFloat(gl, width, height): WebGLTexture {\n\tif (!OES_texture_float_ext) OES_texture_float_ext = gl.getExtension('OES_texture_float');\n\n\tconst texture = gl.createTexture();\n\tconst full = new Float32Array(width * height * 4);\n\tfull.fill(0);\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, full);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\treturn texture;\n}\n\n/** creates a shader of the given type, uploads the source and compiles it. */\nfunction loadShader(gl: WebGLRenderingContext, type: GLenum, source: string) {\n\tconst shader = gl.createShader(type);\n\n\t// Send the source to the shader object\n\n\tgl.shaderSource(shader, source);\n\n\t// Compile the shader program\n\n\tgl.compileShader(shader);\n\n\t// See if it compiled successfully\n\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\talert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n\t\tgl.deleteShader(shader);\n\t\treturn null;\n\t}\n\n\treturn shader;\n}\n\n/** Initialize a shader program, so WebGL knows how to draw our data. */\nexport function initShaderProgram(gl: WebGLRenderingContext, vsSource: string, fsSource: string): WebGLProgram {\n\tconst vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\n\tconst fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\n\n\t// Create the shader program\n\n\tconst shaderProgram = gl.createProgram();\n\tgl.attachShader(shaderProgram, vertexShader);\n\tgl.attachShader(shaderProgram, fragmentShader);\n\tgl.linkProgram(shaderProgram);\n\n\t// If creating the shader program failed, alert\n\n\tif (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n\t\talert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\n\t\treturn null;\n\t}\n\n\treturn shaderProgram;\n}\n\n/**\n * @param gl {WebGLRenderingContext}\n * @param url {string}\n * @returns {Promise<LoadedTexture>} giving a LoadedTexture\n */\nexport function loadTexture(gl: WebGLRenderingContext, url: string): Promise<LoadedTexture> {\n\tconst texture = gl.createTexture();\n\tconst image = new Image();\n\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\treturn new Promise((resolve) => {\n\t\timage.onload = function() {\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t\treturn resolve(new LoadedTexture(texture, image));\n\t\t};\n\t\timage.src = url;\n\t});\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Buffer - memory\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nexport function makeBuffer(gl: WebGLRenderingContext): WebGLBuffer {\n\treturn gl.createBuffer();\n}\n\nexport function memcpy(dst, dstOffset, src, srcOffset, length) {\n\tconst dstU8 = new Uint8Array(dst, dstOffset, length);\n\tconst srcU8 = new Uint8Array(src, srcOffset, length);\n\tdstU8.set(srcU8);\n}\n\nfunction bindToFramebuffer(gl: WebGLRenderingContext, texture: WebGLTexture) {\n\tif (!readPixelsFramebuffer) {\n\t\treadPixelsFramebuffer = gl.createFramebuffer();\n\t}\n\tif (texture) {\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, readPixelsFramebuffer);\n\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\t} else {\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t}\n}\n\n/**\n * @param first {number}\n * @param n {number}\n * @returns {Array} an array with [first, first+1, …, first+n-1]\n */\nexport function makeRangeArray(first: number, n: number): Array<number> {\n\treturn Array.from({length: n}, (v, k) => first + k);\n\t//return Array.apply(null, {length: n}).map(Number.call, Number)\n}\n\n/**\n * @param n {number}\n * @returns {Array} an array with [n-1, n-2, …, 1, 0]\n */\nexport function makeReverseRangeArray(n: number): Array<number> {\n\treturn Array.from({length: n}, (v, k) => n - 1 - k);\n}\n\n/**\n * @param gl\n * @param texture\n * @param x {number} in texels (4 bytes per texel)\n * @param y {number}\n * @param w {number} in texels\n * @param h {number}\n * @returns {Uint8Array}\n */\nexport function readFromTexture32(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number): Uint8Array {\n\tconst result = new Uint8Array(w * h * 4);\n\tbindToFramebuffer(gl, texture);\n\tgl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, result);\n\tbindToFramebuffer(gl, null);\n\treturn result;\n}\n\n/**\n * @param gl\n * @param texture\n * @param x {number} in texels (4 bytes per texel)\n * @param y {number}\n * @param w {number} in texels\n * @param h {number}\n * @param result {Uint8Array}\n */\nexport function readFromTextureToExisting(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number, result: Uint8Array) {\n\tbindToFramebuffer(gl, texture);\n\tgl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, result);\n\tbindToFramebuffer(gl, null);\n}\n\n/**\n * @param gl\n * @param texture\n * @param x {number} in texels (4 bytes per texel)\n * @param y {number}\n * @param w {number} in texels\n * @param h {number}\n * @returns {Float32Array}\n */\nexport function readFromTextureFloat(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number): Float32Array {\n\tconst result = new Float32Array(w * h * 4);\n\tbindToFramebuffer(gl, texture);\n\tgl.readPixels(x, y, w, h, gl.RGBA, gl.FLOAT, result);\n\tbindToFramebuffer(gl, null);\n\treturn result;\n}\n\n/**\n * Do not use this for float arrays!\n * @param gl\n * @param texture\n * @param x {number} in texels (4 bytes per texel)\n * @param y {number}\n * @param w {number} in texels\n * @param h {number}\n * @param array {Uint8Array}\n */\nexport function writeToTexture32(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number, array: Uint8Array) {\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texSubImage2D(gl.TEXTURE_2D, 0,\n\t\tx, y, w, h,\n\t\tgl.RGBA, gl.UNSIGNED_BYTE, array);\n}\n\n/**\n * @param gl\n * @param texture\n * @param x {number} in texels (4 words per texel)\n * @param y {number}\n * @param w {number} in texels\n * @param h {number}\n * @param array {Float32Array}\n */\nexport function writeToTextureFloat(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number, array: Float32Array) {\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texSubImage2D(gl.TEXTURE_2D, 0,\n\t\tx, y, w, h,\n\t\tgl.RGBA, gl.FLOAT, array);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Other\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nexport function TEMP_MakeDualTriangle(array, stride) {\n\t// TODO Florian -- Replace with indexed vertices when possible\n\treturn [].concat.apply([], [\n\t\tarray.slice(0, stride),\n\t\tarray.slice(stride, 2 * stride),\n\t\tarray.slice(3 * stride, 4 * stride),\n\n\t\tarray.slice(0, 1 * stride),\n\t\tarray.slice(3 * stride, 4 * stride),\n\t\tarray.slice(2 * stride, 3 * stride)\n\t]);\n}\n","import {getScalingFactorOfMatrix, initShaderProgram, makeBuffer, makeRangeArray, TEMP_MakeDualTriangle} from \"./utils\";\nimport {\n\tdeclareReadPalette,\n\tdeclareReadTexel,\n\tenvColor,\n\tmakeOutputColor,\n\tPALETTE_HICOLOR_FLAG,\n\tPALETTE_TEX_H,\n\tPALETTE_TEX_W\n} from \"./shaders\";\nimport { DEBUG, VDP } from \"./vdp\";\n\n// How big (tall/wide) a sprite can be before it's broken down in smaller units of OBJ_CELL_SIZE^2\nconst OBJ_CELL_SIZE = 32;\n\nconst OBJ_BUFFER_STRIDE = 6;\n\n// TODO Florian -- Refactor to use zero-based indexes (and document) for all helper functions, like MapBuffer\nexport class ObjBuffer {\n\tname: string;\n\txyzp: Float32Array;\n\tuv: Float32Array;\n\tusedVertices: number = 0;\n\tmaxVertices: number;\n\n\t/**\n\t * @param name {string} for debugging\n\t * @param numVertices {number}\n\t */\n\tconstructor(name, numVertices) {\n\t\tthis.name = name;\n\t\tthis.xyzp = new Float32Array(numVertices * 4);\n\t\tthis.uv = new Float32Array(numVertices * 2);\n\t\tthis.maxVertices = numVertices;\n\t}\n\n\t/**\n\t * Returns the number of cells used.\n\t */\n\tcomputeUsedObjects(first: number = -1, count: number = -1): number {\n\t\tlet result = 0;\n\t\tif (first < 0) first = this.firstSprite;\n\t\tif (count < 0) count = this.usedSprites;\n\n\t\tfor (let i = first; i < first + count; i++) {\n\t\t\tresult += this.computeObjectCells(this.getSizeOfObject(i));\n\t\t}\n\t\treturn result;\n\t}\n\n\tget firstSprite(): number {\n\t\treturn this.firstVertice / OBJ_BUFFER_STRIDE;\n\t}\n\n\t/**\n\t * Returns the first vertice to draw, which is also the last one inserted. In case you want to add a new component,\n\t * subtract from usedVertices (typically 4 or 6 for a quad) then set the buffers at the position of the firstVertice.\n\t * @returns {number} the index of the first vertice in the arrays (there are `usedVertices` then). Note that you'll\n\t * need to multiply by OBJ_BUFFER_STRIDE * <components per entry> to address the arrays.\n\t */\n\tget firstVertice(): number {\n\t\treturn \tthis.maxVertices - this.usedVertices;\n\t}\n\n\t/**\n\t * @returns {number} the z component of an object at the index-th position\n\t * @param index {number}\n\t */\n\tgetZOfObject(index): number {\n\t\treturn this.xyzp[OBJ_BUFFER_STRIDE * 4 * index + 2];\n\t}\n\n\t/**\n\t * Returns the size of an object at the index-th position.\n\t */\n\tgetSizeOfObject(objectIndex: number): {w: number, h: number} {\n\t\t// (left,top) in row 0.xy, (right,bottom) in row 2.xy\n\t\tconst vert = OBJ_BUFFER_STRIDE * 4 * objectIndex;\n\t\treturn {\n\t\t\tw: Math.abs(this.xyzp[vert + 4 * 2] - this.xyzp[vert]),\n\t\t\th: Math.abs(this.xyzp[vert + 4 * 2 + 1] - this.xyzp[vert + 1])\n\t\t};\n\t}\n\n\t/**\n\t * Modifies the OBJ list to fit within the number of cells. Use the return value to know how many sprites to draw.\n\t * @param maxCells {number} maximum allowed number of cells\n\t * @returns {number} sprites fully drawable for this list\n\t */\n\tlimitObjList(maxCells: number): number {\n\t\tlet cells = 0;\n\t\tconst endOfList = this.firstSprite + this.usedSprites;\n\t\tfor (let i = this.firstSprite; i < endOfList; i++) {\n\t\t\tconst size = this.getSizeOfObject(i);\n\t\t\tconst current = this.computeObjectCells(size);\n\n\t\t\tif (cells + current > maxCells) {\n\n\t\t\t\t// TODO Florian -- Limit the width of this sprite -- Doesn't work because we need to scale the UV too with floating point UV rendering\n\t\t\t\t//const cellsTall = Math.ceil(size.h * layerTransform.scaling[1] / OBJ_CELL_SIZE);\n\t\t\t\t//const allowedCellsWide = (maxCells - cells) / cellsTall;\n\t\t\t\t//this.setWidthOfObject(i, allowedCellsWide * OBJ_CELL_SIZE);\n\t\t\t\t//return i - this.firstSprite + 1;\n\n\t\t\t\tif (DEBUG) console.log('Too many OBJ cells on ${this.name} (discarded ${endOfList - i}/${this.usedSprites} entries)');\n\t\t\t\treturn i - this.firstSprite;\n\t\t\t}\n\t\t\tcells += current;\n\t\t}\n\t\treturn this.usedSprites;\n\t}\n\n\t// Limit the width of an object (usually as a result of going outside of the sprite limit).\n\t// setWidthOfObject(objectIndex: number, width: number) {\n\t// \t// (left,top) in row 0.xy, (right,bottom) in row 2.xy\n\t// \tconst vert = OBJ_BUFFER_STRIDE * 4 * objectIndex;\n\t// \tthis.xyzp[vert + 4 * 2] = this.xyzp[vert] + width;\n\t// }\n\n\tsort(frontToBack = true) {\n\t\tconst items = makeRangeArray(this.firstVertice / OBJ_BUFFER_STRIDE, this.usedVertices / OBJ_BUFFER_STRIDE);\n\t\tif (frontToBack) {\n\t\t\t// First vertice, z component (3rd)\n\t\t\titems.sort((a, b) => this.getZOfObject(b) - this.getZOfObject(a));\n\t\t} else {\n\t\t\titems.sort((a, b) => this.getZOfObject(a) - this.getZOfObject(b));\n\t\t}\n\n\t\tconst originalXyzp = this.xyzp.slice();\n\t\tconst originalUv = this.uv.slice();\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tthis.xyzp.set(\n\t\t\t\toriginalXyzp.subarray(OBJ_BUFFER_STRIDE * 4 * items[i], OBJ_BUFFER_STRIDE * 4 * (items[i] + 1)),\n\t\t\t\tOBJ_BUFFER_STRIDE * 4 * i);\n\t\t\tthis.uv.set(\n\t\t\t\toriginalUv.subarray(OBJ_BUFFER_STRIDE * 2 * items[i], OBJ_BUFFER_STRIDE * 2 * (items[i] + 1)),\n\t\t\t\tOBJ_BUFFER_STRIDE * 2 * i);\n\t\t}\n\t}\n\n\tget usedSprites(): number {\n\t\treturn this.usedVertices / OBJ_BUFFER_STRIDE;\n\t}\n\n\t/**\n\t * Computes the number of pixels that an object uses with the transform. Note that even offscreen pixels count toward\n\t * the limit!\n\t */\n\tprivate computeObjectCells(size: {w: number, h: number}): number {\n\t\treturn Math.max(1, Math.ceil(size.w / OBJ_CELL_SIZE) * Math.ceil(size.h / OBJ_CELL_SIZE));\n\t}\n}\n\nexport function initObjShaders(vdp: VDP) {\n\tconst gl = vdp.gl;\n\t// Vertex shader program\n\tconst vsSource = `\n\t\t\t// The 3 first are the vertex position, the 4th is the palette ID\n\t\t\tattribute vec4 aXyzp;\n\t\t\t// The 2 first are the texture position\n\t\t\tattribute vec2 aUv;\n\t\n\t\t\tuniform mat3 uModelViewMatrix;\n\t\t\tuniform mat4 uProjectionMatrix;\n\t\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvarying highp float vPaletteNo;\n\t\t\tuniform sampler2D uSamplerSprites, uSamplerPalettes;\n\t\t\n\t\t\tvoid main(void) {\n\t\t\t\t// Only scale the final matrix (we can always say that the VDP supports fixed point math inside for matrix multiplication)\n\t\t\t\tgl_Position = uProjectionMatrix * vec4(floor(uModelViewMatrix * vec3(aXyzp.xy, aXyzp.z)), 1);\n\t\t\t\tvPaletteNo = aXyzp.w;\n\t\t\t\tvTextureCoord = floor(aUv);\n\t\t\t}\n\t\t`;\n\tconst fsSource = `\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvarying highp float vPaletteNo;\n\t\t\tuniform vec4 uEnvColor;\n\t\t\tuniform sampler2D uSamplerSprites, uSamplerPalettes;\n\t\n\t\t\t${declareReadTexel()}\n\t\t\t${declareReadPalette()}\n\t\t\n\t\t\tvoid main(void) {\n\t\t\t\tfloat texel, palette;\n\t\t\t\tif (vPaletteNo >= ${PALETTE_HICOLOR_FLAG}.0) {\n\t\t\t\t\ttexel = readTexel8(vTextureCoord.x, vTextureCoord.y);\n\t\t\t\t\tpalette = (vPaletteNo - ${PALETTE_HICOLOR_FLAG}.0) / ${PALETTE_TEX_H}.0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttexel = readTexel4(vTextureCoord.x, vTextureCoord.y);\n\t\t\t\t\tpalette = vPaletteNo / ${PALETTE_TEX_H}.0;\n\t\t\t\t}\n\n\t\t\t\t// Color zero\n\t\t\t\tif (texel < ${1.0 / (PALETTE_TEX_W)}) discard;\n\n\t\t\t\tvec4 color = readPalette(texel, palette);\n\t\t\t\tgl_FragColor = ${makeOutputColor('color')};\n\t\t\t}\n\t\t`;\n\n\t// TODO Florian -- Use indexed VAOs\n\tconst shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n\n\tvdp.spriteProgram = {\n\t\tprogram: shaderProgram,\n\t\tattribLocations: {\n\t\t\txyzp: gl.getAttribLocation(shaderProgram, 'aXyzp'),\n\t\t\tuv: gl.getAttribLocation(shaderProgram, 'aUv'),\n\t\t},\n\t\tglBuffers: {\n\t\t\txyzp: makeBuffer(gl),\n\t\t\tuv: makeBuffer(gl)\n\t\t},\n\t\tuniformLocations: {\n\t\t\tenvColor: gl.getUniformLocation(shaderProgram, 'uEnvColor'),\n\t\t\tprojectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\n\t\t\tmodelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\n\t\t\tuSamplerSprites: gl.getUniformLocation(shaderProgram, 'uSamplerSprites'),\n\t\t\tuSamplerPalettes: gl.getUniformLocation(shaderProgram, 'uSamplerPalettes'),\n\t\t},\n\t};\n}\n\n/**\n * @param vdp {VDP}\n * @param objBuffer {ObjBuffer}\n * @param objLimit {number} max number of cells drawable\n */\nexport function drawPendingObj(vdp: VDP, objBuffer: ObjBuffer, objLimit: number = 0) {\n\tlet numObjectsToDraw = objBuffer.usedSprites;\n\tif (objLimit > 0) numObjectsToDraw = objBuffer.limitObjList(objLimit);\n\tif (numObjectsToDraw <= 0) return;\n\n\tconst prog = vdp.spriteProgram;\n\tconst gl = vdp.gl;\n\n\tconst firstVertice = objBuffer.firstVertice;\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\n\tgl.bufferData(gl.ARRAY_BUFFER, objBuffer.xyzp.subarray(firstVertice * 4), gl.STREAM_DRAW);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.uv);\n\tgl.bufferData(gl.ARRAY_BUFFER, objBuffer.uv.subarray(firstVertice * 2), gl.STREAM_DRAW);\n\n\tgl.useProgram(prog.program);\n\t{\n\t\tconst numComponents = 4;  // pull out 4 values per iteration\n\t\tconst type = gl.FLOAT;    // the data in the buffer is 32bit floats\n\t\tconst normalize = false;  // don't normalize\n\t\tconst stride = 0;         // how many bytes to get from one set of values to the next\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 0 = use type and numComponents above\n\t\tconst offset = 0;         // how many bytes inside the buffer to start from\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\n\t\tgl.vertexAttribPointer(prog.attribLocations.xyzp, numComponents, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.xyzp);\n\t}\n\t{\n\t\tconst num = 2, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.uv);\n\t\tgl.vertexAttribPointer(prog.attribLocations.uv, num, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.uv);\n\t}\n\n\t// Tell WebGL we want to affect texture unit 0\n\tgl.activeTexture(gl.TEXTURE0);\n\t// Bind the texture to texture unit 0\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.spriteTexture);\n\tgl.activeTexture(gl.TEXTURE1);\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.paletteTexture);\n\n\t// Tell the shader we bound the texture to texture unit 0\n\tgl.uniform1i(prog.uniformLocations.uSamplerSprites, 0);\n\tgl.uniform1i(prog.uniformLocations.uSamplerPalettes, 1);\n\n\t// Set the shader uniforms\n\tgl.uniformMatrix4fv(prog.uniformLocations.projectionMatrix, false, vdp.projectionMatrix);\n\tgl.uniformMatrix3fv(prog.uniformLocations.modelViewMatrix,false, vdp.modelViewMatrix);\n\n\tgl.uniform4f(prog.uniformLocations.envColor, envColor[0], envColor[1], envColor[2], envColor[3]);\n\n\tgl.drawArrays(gl.TRIANGLES, 0, numObjectsToDraw * OBJ_BUFFER_STRIDE);\n\n\tobjBuffer.usedVertices = 0;\n}\n\nexport function enqueueObj(objBuffer: ObjBuffer, xStart: number, yStart: number, xEnd: number, yEnd: number, uStart: number, vStart: number, uEnd: number, vEnd: number, palNo: number, hiColor: boolean, z: number = 0) {\n\tif (hiColor) palNo |= PALETTE_HICOLOR_FLAG;\n\n\tif (objBuffer.usedVertices >= objBuffer.maxVertices) {\n\t\tif (DEBUG) console.log(`${objBuffer.name} overuse (max ${objBuffer.maxVertices / OBJ_BUFFER_STRIDE}), ignoring drawOBJ`);\n\t\treturn;\n\t}\n\n\t// Start from the end\n\tobjBuffer.usedVertices += OBJ_BUFFER_STRIDE;\n\tconst firstVertice = objBuffer.firstVertice;\n\n\tobjBuffer.xyzp.set(TEMP_MakeDualTriangle([\n\t\txStart, yStart, z, palNo,\n\t\txEnd, yStart, z, palNo,\n\t\txStart, yEnd, z, palNo,\n\t\txEnd, yEnd, z, palNo,\n\t], 4), 4 * firstVertice);\n\n\tobjBuffer.uv.set(TEMP_MakeDualTriangle([\n\t\tuStart, vStart,\n\t\tuEnd, vStart,\n\t\tuStart, vEnd,\n\t\tuEnd, vEnd,\n\t], 2), 2 * firstVertice);\n\n}\n\nexport function makeObjBuffer(name: string, numSprites: number): ObjBuffer {\n\treturn new ObjBuffer(name, numSprites * OBJ_BUFFER_STRIDE);\n}\n","import {initShaderProgram, makeBuffer, TEMP_MakeDualTriangle} from \"./utils\";\nimport {\n\tdeclareReadPalette,\n\tdeclareReadTexel,\n\tenvColor,\n\tmakeOutputColor,\n\tMAP_TEX_H,\n\tMAP_TEX_W,\n\tOTHER_TEX_H,\n\tOTHER_TEX_W,\n\tPALETTE_HICOLOR_FLAG,\n\tPALETTE_TEX_H,\n\tPALETTE_TEX_W\n} from \"./shaders\";\nimport { DEBUG, VDP } from \"./vdp\";\n\nconst BG_BUFFER_STRIDE = 6;\n\nexport class MapBuffer {\n\tname: string;\n\txyzp: Float32Array;\n\tmapInfo1: Float32Array;\n\tmapInfo2: Float32Array;\n\tmapInfo3: Float32Array;\n\tmapInfo4: Float32Array;\n\tusedVertices: number = 0;\n\tmaxVertices: number;\n\n\tconstructor(name: string, numVertices: number) {\n\t\tthis.name = name;\n\t\tthis.xyzp = new Float32Array(numVertices * 4);\n\t\tthis.mapInfo1 = new Float32Array(numVertices * 4);\n\t\tthis.mapInfo2 = new Float32Array(numVertices * 4);\n\t\tthis.mapInfo3 = new Float32Array(numVertices * 4);\n\t\tthis.mapInfo4 = new Float32Array(numVertices * 4);\n\t\tthis.maxVertices = numVertices;\n\t}\n\n\t/**\n\t * @returns {number} the index of the first vertice in the arrays (there are `usedVertices` then). Note that you'll\n\t * need to multiply by OBJ_BUFFER_STRIDE * <components per entry> to address the arrays.\n\t */\n\tget firstVertice(): number {\n\t\treturn \tthis.maxVertices - this.usedVertices;\n\t}\n\n\tget usedLayers(): number {\n\t\treturn this.usedVertices / BG_BUFFER_STRIDE;\n\t}\n}\n\nexport function initMapShaders(vdp: VDP) {\n\tconst gl = vdp.gl;\n\t// Vertex shader program\n\tconst vsSource = `\n\t\t\tattribute vec4 aXyzp;\n\t\t\tattribute vec4 aMapInfo1;\n\t\t\tattribute vec4 aMapInfo2;\n\t\t\tattribute vec4 aMapInfo3;\n\t\t\tattribute vec4 aMapInfo4;\n\t\t\tuniform mat3 uModelViewMatrix;\n\t\t\tuniform mat4 uProjectionMatrix;\n\n\t\t\tvarying vec2 vTextureCoord;\n\t\t\tvarying float vPaletteNo;\n\t\t\t// TODO Florian -- use vec4 and extract in fragment program\n\t\t\tvarying highp vec2 vMapStart;\n\t\t\tvarying highp vec2 vMapSize;\n\t\t\tvarying vec2 vTilesetStart;\n\t\t\tvarying float vTilesetWidth;\n\t\t\tvarying vec2 vTileSize;\n\t\t\tvarying mat3 vTransformationMatrix;\n\t\t\t// [0] = linescroll buffer, if 0 use vTransformationMatrix always, [1] = whether to wrap around\n\t\t\tvarying vec2 vOtherInfo;\n\t\t\t\n\t\t\tuniform sampler2D uSamplerMaps, uSamplerSprites, uSamplerPalettes, uSamplerOthers;\n\t\t\n\t\t\tmat3 readLinescrollBuffer(int bufferNo, int horizOffset) {\n\t\t\t\tfloat vOfs = float(bufferNo) / ${OTHER_TEX_H}.0;\n\t\t\t\tvec4 first = texture2D(uSamplerOthers, vec2(float(horizOffset) / ${OTHER_TEX_W}.0, vOfs));\n\t\t\t\tvec4 second = texture2D(uSamplerOthers, vec2(float(horizOffset + 1) / ${OTHER_TEX_W}.0, vOfs));\n\t\t\t\treturn mat3(\n\t\t\t\t\tfirst.xy, 0,\n\t\t\t\t\tvec2(first.a, second.r), 0,\n\t\t\t\t\tsecond.ba, 1.0);\n\t\t\t}\n\t\t\n\t\t\tvoid main(void) {\n\t\t\t\t// Only scale the final matrix (we can always say that the VDP supports fixed point math inside for matrix multiplication)\n\t\t\t\tgl_Position = uProjectionMatrix * vec4(floor(uModelViewMatrix * aXyzp.xyz), 1);\n\t\t\t\tvPaletteNo = floor(aXyzp.w);\n\t\t\t\tvMapStart = floor(aMapInfo1.xy);\n\t\t\t\tvTilesetStart = floor(aMapInfo1.zw);\n\t\t\t\tvMapSize = floor(aMapInfo2.xy);\n\t\t\t\tvTilesetWidth = floor(aMapInfo2.z);\n\t\t\t\tvTileSize = floor(aMapInfo3.xy);\n\t\t\t\tvTextureCoord = floor(aMapInfo3.zw);\n\t\t\t\tvOtherInfo = floor(aMapInfo4.xy);\n\t\t\t\t// If 0-255, use one transformation map-wide from the first line, if -1 never use transformations\n\t\t\t\tif (aMapInfo4.x >= 0.0 && aMapInfo4.x < 256.0) {\n\t\t\t\t\tvTransformationMatrix = readLinescrollBuffer(0, int(aMapInfo4.x) * 2);\n\t\t\t\t} else {\n\t\t\t\t\tvTransformationMatrix = mat3(\n\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t0, 0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t`;\n\tconst fsSource = `\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvarying highp float vPaletteNo;\n\t\t\tvarying highp vec2 vMapStart;\n\t\t\tvarying highp vec2 vMapSize;\n\t\t\t// tilesetSize is in tiles!\n\t\t\tvarying vec2 vTilesetStart;\n\t\t\tvarying float vTilesetWidth;\n\t\t\tvarying vec2 vTileSize;\n\t\t\tvarying mat3 vTransformationMatrix;\n\t\t\tvarying vec2 vOtherInfo;\n\t\t\t\n\t\t\tuniform mat3 uModelViewMatrix;\n\t\t\tuniform vec4 uEnvColor;\n\t\t\tuniform sampler2D uSamplerMaps, uSamplerSprites, uSamplerPalettes, uSamplerOthers;\n\t\t\t\t\t\t\n\t\t\tint intDiv(float x, float y) {\n\t\t\t\treturn int(floor(x / y));\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns accurate MOD when arguments are approximate integers.\n\t\t\t * https://stackoverflow.com/questions/33908644/get-accurate-integer-modulo-in-webgl-shader\n\t\t\t */\n\t\t\tfloat modI(float a,float b) {\n\t\t\t\tfloat m=a-floor((a+0.5)/b)*b;\n\t\t\t\treturn floor(m+0.5);\n\t\t\t}\n\n\t\t\tmat3 readLinescrollBuffer(int bufferNo, int horizOffset) {\n\t\t\t\tfloat vOfs = float(bufferNo) / ${OTHER_TEX_H}.0;\n\t\t\t\tvec4 first = texture2D(uSamplerOthers, vec2(float(horizOffset) / ${OTHER_TEX_W}.0, vOfs));\n\t\t\t\tvec4 second = texture2D(uSamplerOthers, vec2(float(horizOffset + 1) / ${OTHER_TEX_W}.0, vOfs));\n\t\t\t\treturn mat3(\n\t\t\t\t\tfirst.r, first.g, 0,\n\t\t\t\t\tfirst.a, second.r, 0,\n\t\t\t\t\tsecond.b, second.a, 1);\n\t\t\t}\n\t\t\t\n\t\t\tint readMap(int x, int y) {\n\t\t\t\tx = int(modI(float(x), vMapSize.x) + vMapStart.x);\n\t\t\t\ty = int(modI(float(y), vMapSize.y) + vMapStart.y);\n\t\t\t\t\n\t\t\t\tint texelId = x / 2;\n\t\t\t\tint texelC = x - texelId * 2;\n\t\t\t\tvec4 read = texture2D(uSamplerMaps, vec2(float(texelId) / ${MAP_TEX_W}.0, float(y) / ${MAP_TEX_H}.0));\n\t\t\t\tif (texelC == 0) return int(read.r * 255.0) + int(read.g * 255.0) * 256;\n\t\t\t\treturn int(read.b * 255.0) + int(read.a * 255.0) * 256;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 positionInTexture(int tileNo) {\n\t\t\t\tvec2 base = vTilesetStart;\n\t\t\t\tfloat rowNo = float(tileNo / int(vTilesetWidth));\n\t\t\t\tfloat colNo = modI(float(tileNo), vTilesetWidth);\n\t\t\t\treturn base + vec2(colNo * vTileSize.x, rowNo * vTileSize.y);\n\t\t\t}\n\t\t\n\t\t\t${declareReadTexel()}\n\t\t\t${declareReadPalette()}\n\t\t\n\t\t\tvoid main(void) {\n\t\t\t\tmat3 transformationMatrix;\n\t\t\t\tfloat y = vTextureCoord.y;\n\t\t\t\t// Per-line info\n\t\t\t\tif (vOtherInfo.x >= 256.0) {\n\t\t\t\t\t// 2 colors (8 float values) per matrix\n\t\t\t\t\ttransformationMatrix = readLinescrollBuffer(int(vOtherInfo.x) - 256, int(y) * 2);\n\t\t\t\t\ty = 0.0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttransformationMatrix = vTransformationMatrix;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texCoord = floor((transformationMatrix * vec3(vTextureCoord.x, y, 1)).xy);\n\t\t\t\tint mapX = intDiv(texCoord.x, vTileSize.x), mapY = intDiv(texCoord.y, vTileSize.y);\n\t\t\t\t\n\t\t\t\t// Out of bounds?\n\t\t\t\tif (vOtherInfo.y < 1.0 && (mapX < 0 || mapY < 0 || mapX >= int(vMapSize.x) || mapY >= int(vMapSize.y))) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint mapTileNo = readMap(mapX, mapY);\n\t\t\t\t// Invisible tile (TODO Florian -- support in the converter)\n\t\t\t\tif (mapTileNo >= 65535) discard;\n\n\t\t\t\t// Bits 12-15: palette No\n\t\t\t\tint palOfs = mapTileNo / ${1 << 12};\n\t\t\t\tfloat paletteOffset = float(palOfs);\n\t\t\t\tmapTileNo -= palOfs * ${1 << 12};\n\n\t\t\t\t// Position of tile no in sprite texture, now we need to add the offset\n\t\t\t\tvec2 offsetInTile = vec2(int(texCoord.x) - mapX * int(vTileSize.x), int(texCoord.y) - mapY * int(vTileSize.y));\n\t\t\t\tvec2 tilesetPos = positionInTexture(mapTileNo) + offsetInTile;\n\t\t\t\tfloat texel;\n\n\t\t\t\tif (vPaletteNo >= ${PALETTE_HICOLOR_FLAG}.0) {\n\t\t\t\t\ttexel = readTexel8(tilesetPos.x, tilesetPos.y);\n\t\t\t\t\tpaletteOffset += (vPaletteNo - ${PALETTE_HICOLOR_FLAG}.0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttexel = readTexel4(tilesetPos.x, tilesetPos.y);\n\t\t\t\t\tpaletteOffset += vPaletteNo;\n\t\t\t\t}\n\n\t\t\t\t// if (vTextureCoord.x < 16.0) {\n\t\t\t\t// \tvec4 color = vec4(0, 0, 0, 1);\n\t\t\t\t// \t// float ym = mod(float(mapY), vMapSize.y) + vMapStart.y;\n\t\t\t\t// \t// color.b = (float(mapY) - ( float(mapY / int(vMapSize.y))) / 2.0;\n\t\t\t\t// \tint times = intDiv(float(mapY), vMapSize.y - 0.001);\n\t\t\t\t// \tcolor.g = modI(float(mapY), vMapSize.y) / 2.0;\n\t\t\t\t// \tcolor.b = float(mapY) / 28.0;\n\t\t\t\t// \tgl_FragColor = color;\n\t\t\t\t// }\n\t\t\t\t// else {\n\t\t\t\t\t// Color zero\n\t\t\t\t\tif (texel < ${1.0 / PALETTE_TEX_W}) discard;\n\t\t\t\t\n\t\t\t\t\tvec4 color = readPalette(texel, paletteOffset / ${PALETTE_TEX_H}.0);\n\t\t\t\t\tgl_FragColor = ${makeOutputColor('color')};\n\t\t\t\t// }\n\t\t\t}\n\t\t`;\n\n\tconst shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n\tvdp.mapProgram = {\n\t\tprogram: shaderProgram,\n\t\tattribLocations: {\n\t\t\txyzp: gl.getAttribLocation(shaderProgram, 'aXyzp'),\n\t\t\tmapInfo1: gl.getAttribLocation(shaderProgram, 'aMapInfo1'),\n\t\t\tmapInfo2: gl.getAttribLocation(shaderProgram, 'aMapInfo2'),\n\t\t\tmapInfo3: gl.getAttribLocation(shaderProgram, 'aMapInfo3'),\n\t\t\tmapInfo4: gl.getAttribLocation(shaderProgram, 'aMapInfo4')\n\t\t},\n\t\tglBuffers: {\n\t\t\txyzp: makeBuffer(gl),\n\t\t\tmapInfo1: makeBuffer(gl),\n\t\t\tmapInfo2: makeBuffer(gl),\n\t\t\tmapInfo3: makeBuffer(gl),\n\t\t\tmapInfo4: makeBuffer(gl)\n\t\t},\n\t\tuniformLocations: {\n\t\t\tenvColor: gl.getUniformLocation(shaderProgram, 'uEnvColor'),\n\t\t\tprojectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\n\t\t\tmodelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\n\t\t\tuSamplerMaps: gl.getUniformLocation(shaderProgram, 'uSamplerMaps'),\n\t\t\tuSamplerSprites: gl.getUniformLocation(shaderProgram, 'uSamplerSprites'),\n\t\t\tuSamplerPalettes: gl.getUniformLocation(shaderProgram, 'uSamplerPalettes'),\n\t\t\tuSamplerOthers: gl.getUniformLocation(shaderProgram, 'uSamplerOthers'),\n\t\t},\n\t};\n}\n\nexport function drawPendingMap(vdp: VDP, mapBuffer: MapBuffer) {\n\tif (mapBuffer.usedVertices < 3) return;\n\n\tconst gl = vdp.gl;\n\tconst prog = vdp.mapProgram;\n\tconst firstVertice = mapBuffer.firstVertice;\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.xyzp.subarray(firstVertice * 4), gl.STREAM_DRAW);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo1);\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo1.subarray(firstVertice * 4), gl.STREAM_DRAW);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo2);\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo2.subarray(firstVertice * 4), gl.STREAM_DRAW);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo3);\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo3.subarray(firstVertice * 4), gl.STREAM_DRAW);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo4);\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo4.subarray(firstVertice * 4), gl.STREAM_DRAW);\n\n\tgl.useProgram(prog.program);\n\t{\n\t\tconst numComponents = 4;  // pull out 4 values per iteration\n\t\tconst type = gl.FLOAT;    // the data in the buffer is 32bit floats\n\t\tconst normalize = false;  // don't normalize\n\t\tconst stride = 0;         // how many bytes to get from one set of values to the next\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 0 = use type and numComponents above\n\t\tconst offset = 0;         // how many bytes inside the buffer to start from\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\n\t\tgl.vertexAttribPointer(prog.attribLocations.xyzp, numComponents, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.xyzp);\n\t}\n\t{\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo1);\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo1, num, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo1);\n\t}\n\t{\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo2);\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo2, num, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo2);\n\t}\n\t{\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo3);\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo3, num, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo3);\n\t}\n\t{\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo4);\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo4, num, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo4);\n\t}\n\n\t// Tell WebGL we want to affect texture unit 0\n\tgl.activeTexture(gl.TEXTURE0);\n\t// Bind the texture to texture unit 0\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.spriteTexture);\n\tgl.activeTexture(gl.TEXTURE1);\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.paletteTexture);\n\tgl.activeTexture(gl.TEXTURE2);\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.mapTexture);\n\tgl.activeTexture(gl.TEXTURE3);\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.otherTexture);\n\n\t// Tell the shader we bound the texture to texture unit 0\n\tgl.uniform1i(prog.uniformLocations.uSamplerSprites, 0);\n\tgl.uniform1i(prog.uniformLocations.uSamplerPalettes, 1);\n\tgl.uniform1i(prog.uniformLocations.uSamplerMaps, 2);\n\tgl.uniform1i(prog.uniformLocations.uSamplerOthers, 3);\n\n\t// Set the shader uniforms\n\tgl.uniformMatrix4fv(prog.uniformLocations.projectionMatrix, false, vdp.projectionMatrix);\n\tgl.uniformMatrix3fv(prog.uniformLocations.modelViewMatrix,false, vdp.modelViewMatrix);\n\n\tgl.uniform4f(prog.uniformLocations.envColor, envColor[0], envColor[1], envColor[2], envColor[3]);\n\n\tgl.drawArrays(gl.TRIANGLES, 0, mapBuffer.usedVertices);\n\n\tmapBuffer.usedVertices = 0;\n}\n\nexport function enqueueMap(mapBuffer: MapBuffer, uMap: number, vMap: number, uTileset: number, vTileset: number, mapWidth: number, mapHeight: number, tilesetWidth: number, tileWidth: number, tileHeight: number, winX: number, winY: number, winW: number, winH: number, scrollX: number, scrollY: number, palNo: number, hiColor: boolean, linescrollBuffer: number = -1, wrap: number = 1, z: number = 0) {\n\n\t// Remove the + win* to start the map at the window instead of continuing it\n\tscrollX += winX;\n\tscrollY += winY;\n\n\ttilesetWidth = Math.floor(tilesetWidth / tileWidth);\n\tif (hiColor) palNo |= PALETTE_HICOLOR_FLAG;\n\n\tif (mapBuffer.usedVertices >= mapBuffer.maxVertices) {\n\t\tif (DEBUG) console.log(`${mapBuffer.name} overuse (max ${mapBuffer.maxVertices / BG_BUFFER_STRIDE}), ignoring drawBG`);\n\t\treturn;\n\t}\n\tmapBuffer.usedVertices += BG_BUFFER_STRIDE;\n\tconst firstVertice = mapBuffer.firstVertice;\n\n\t// x, y position, z for normal-prio tiles, base palette no\n\tmapBuffer.xyzp.set(TEMP_MakeDualTriangle([\n\t\twinX, winY, z, palNo,\n\t\twinX + winW, winY, z, palNo,\n\t\twinX, winY + winH, z, palNo,\n\t\twinX + winW, winY + winH, z, palNo,\n\t], 4), 4 * firstVertice);\n\t// u, v map base, u, v tileset base\n\tmapBuffer.mapInfo1.set(TEMP_MakeDualTriangle([\n\t\tuMap, vMap, uTileset, vTileset,\n\t\tuMap, vMap, uTileset, vTileset,\n\t\tuMap, vMap, uTileset, vTileset,\n\t\tuMap, vMap, uTileset, vTileset\n\t], 4), 4 * firstVertice);\n\t// map width, map height, tileset width, z for hi-prio tiles\n\tmapBuffer.mapInfo2.set(TEMP_MakeDualTriangle([\n\t\tmapWidth, mapHeight, tilesetWidth, 0,\n\t\tmapWidth, mapHeight, tilesetWidth, 0,\n\t\tmapWidth, mapHeight, tilesetWidth, 0,\n\t\tmapWidth, mapHeight, tilesetWidth, 0\n\t], 4), 4 * firstVertice);\n\t// tile width, tile height, drawing uv\n\tmapBuffer.mapInfo3.set(TEMP_MakeDualTriangle([\n\t\ttileWidth, tileHeight, scrollX, scrollY,\n\t\ttileWidth, tileHeight, scrollX + winW, scrollY,\n\t\ttileWidth, tileHeight, scrollX, scrollY + winH,\n\t\ttileWidth, tileHeight, scrollX + winW, scrollY + winH\n\t], 4), 4 * firstVertice);\n\t// linescroll buffer (row no in otherTexture), whether to wrap around map size (0=off, 1=on)\n\tmapBuffer.mapInfo4.set(TEMP_MakeDualTriangle([\n\t\tlinescrollBuffer, wrap, 0, 0,\n\t\tlinescrollBuffer, wrap, 0, 0,\n\t\tlinescrollBuffer, wrap, 0, 0,\n\t\tlinescrollBuffer, wrap, 0, 0\n\t], 4), 4 * firstVertice);\n}\n\n/**\n * @param name {string} for debugging\n * @param numMaps {number} number of maps that may be contained (batched) inside the map buffer.\n * @returns {MapBuffer}\n */\nexport function makeMapBuffer(name: string, numMaps: number): MapBuffer {\n\treturn new MapBuffer(name, numMaps * BG_BUFFER_STRIDE);\n}\n","export class VdpMap {\n\tx: number; // U position in the map texture (cells)\n\ty: number; // V position in the map texture (cells)\n\tw: number; // width of sprite (pixels)\n\th: number; // height of sprite (pixels)\n\tdesignTileset: string; // name of the tileset (VdpSprite)\n\tdesignPalette: string; // name of the first palette (takes precedence over the one defined in the tileset); tiles can use this and the next 15 palettes via the bits 12-15 in the tile number.\n\n\tconstructor(x: number, y: number, w: number, h: number, designTileset: string, designPalette: string) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t\tthis.designTileset = designTileset;\n\t\tthis.designPalette = designPalette;\n\t}\n\n\toffsetted(x: number, y: number, w: number, h: number): VdpMap {\n\t\tthis.x += x;\n\t\tthis.y += y;\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t\treturn this;\n\t}\n}\n\nexport class VdpPalette {\n\ty: number; // V position of palette (color units)\n\tw: number; // count (color units)\n\th: number; // number of rows (consecutive palettes)\n\n\tconstructor(y: number, w: number, h: number) {\n\t\tthis.y = y;\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t}\n\n\toffsetted(y: number, w: number, h: number): VdpPalette {\n\t\tthis.y += y;\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t\treturn this;\n\t}\n}\n\nexport class VdpSprite {\n\tx: number; // U position in the sprite texture (pixels)\n\ty: number; // V position in the sprite texture (pixels)\n\tw: number; // width of sprite or tileset as a whole (pixels)\n\th: number; // height of sprite or tileset as a whole (pixels)\n\ttw: number; // tile width (pixels) if it's a tileset\n\tth: number; // tile height (pixels) if it's a tileset\n\ttiles: number; // number of (used) tiles in the tileset\n\thiColor: boolean; // whether it's a 8-bit-per-pixel tile (or 4-bit)\n\tdesignPalette: string; // design palette name (can be overriden)\n\n\tconstructor(x: number, y: number, w: number, h: number, tw: number, th: number, tiles: number, hiColor: boolean, designPalette: string) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t\tthis.tw = tw;\n\t\tthis.th = th;\n\t\tthis.tiles = tiles;\n\t\tthis.hiColor = hiColor;\n\t\tthis.designPalette = designPalette;\n\t}\n\n\toffsetted(x: number, y: number, w: number, h: number): VdpSprite {\n\t\tthis.x += x;\n\t\tthis.y += y;\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Modifies this instance of VdpSprite (not the original) to target a given tile in a tileset.\n\t * @throws {Error} if this sprite is not a tileset.\n\t * @param no tile number to target.\n\t * @returns {VdpSprite} this\n\t */\n\ttile(no: number): VdpSprite {\n\t\tconst columnsPerRow = Math.floor(this.w / this.tw);\n\t\tif (this.w / this.tw !== columnsPerRow) {\n\t\t\tthrow new Error(`Not a tileset (w=${this.w}, h=${this.h}, tw=${this.tw})`)\n\t\t}\n\n\t\tconst col = no % columnsPerRow;\n\t\tconst row = Math.floor(no / columnsPerRow);\n\t\treturn this.offsetted(col * this.tw, row * this.th, this.tw, this.th);\n\t}\n}\n\n/**\n * Used to represent data read from (or written to) memory.\n *\n * In the VDP16, memory is always addressed in 2D. It has the advantage of being easier to represent for users and be\n * much more flexible. However, underlying memory is still exposed as a one-dimensional array in the end, containing\n * [height] lines of [width] integers, each of which represents a pixel, a map element or a palette color. Therefore,\n * accessing to the buffer element (x, y) is done as such: Array2D.buffer[x + y * width]. Since it's heavily used all\n * around, we created this class to wrap up the data buffer and the width of each column.\n *\n * For reference, sprites use 8 bit data (Uint8Array), each element being one or two pixels depending on the hi-color\n * mode. Map elements use 16 bit data (Uint16Array), each element being a map element. Palettes use 32 bit data\n * (Uint32Array), each element representing a color in RGBA format (write 0xaabbggrr with r=8 red bits, g=green, b=blue\n * and a=alpha, ignored unless you use the alpha-based blending modes).\n */\nexport class Array2D {\n\tbuffer: Uint8Array|Uint16Array|Uint32Array;\n\twidth: number;\n\theight: number;\n\n\tconstructor(buffer: Uint8Array|Uint16Array|Uint32Array, width: number, height: number) {\n\t\tthis.buffer = buffer;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\n\tgetElement(x: number, y: number): number {\n\t\treturn this.buffer[this.width * y + x];\n\t}\n\n\tsetElement(x: number, y: number, value: number) {\n\t\tthis.buffer[this.width * y + x] = value;\n\t}\n}\n\n/**\n * Fills the memory with a given value.\n */\nexport function memset(buffer: Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array, value: number, numEntries: number) {\n\tbuffer.fill(value, 0, numEntries);\n}\n\nexport function memcpy(dst: Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array, src: Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array) {\n\tdst.set(src);\n}\n","\nexport class color32 {\n\t/**\n\t * @param c color (32 bits)\n\t * @param [bitsPerComponent=8] {number} can be 2, 3, 4, 5 to return a reduced color value (x bits per component)\n\t * @returns {{r: number, g: number, b: number, a: number}}\n\t */\n\tstatic extract(c: number, bitsPerComponent: number = 8): { a: number; b: number; r: number; g: number } {\n\t\tc = color32.posterize(c, bitsPerComponent);\n\t\treturn {\n\t\t\ta: c >>> 24,\n\t\t\tb: c >>> 16 & 0xff,\n\t\t\tg: c >>> 8 & 0xff,\n\t\t\tr: c & 0xff,\n\t\t};\n\t}\n\n\t/**\n\t * Use make( { r: …, g: …, …} ) or make(r, g, b).\n\t * @param r {number|{r: number, g: number, b: number, a: number}} red component (0 to 255) or color as extracted with\n\t * color32.extract().\n\t * @param [g] {number} green component (0 to 255)\n\t * @param [b] {number} blue component (0 to 255)\n\t * @param [a=255] {number} alpha component (not used, only required to make a valid color for your display adapter)\n\t * @returns {number} resulting color\n\t */\n\tstatic make(r: number|{r: number, g: number, b: number, a: number}, g: number = 0, b: number = 0, a: number = 0xff): number {\n\t\tif (typeof r === 'number') return r | g << 8 | b << 16 | a << 24;\n\t\treturn r.r | r.g << 8 | r.b << 16 | r.a << 24;\n\t}\n\n\t/**\n\t * Extends a 16 bit RGBA color into a 32 bit RGBA color. Note that 0xRGBA will produce 0xAABBGGRR, reversing the byte\n\t * order as OpenGL expects it.\n\t * @param col {number}\n\t * @returns {number}\n\t */\n\tstatic extendColor12(col: number): number {\n\t\treturn color32.reverseColor32((col & 0xf) | (col & 0xf) << 4 |\n\t\t\t(col & 0xf0) << 4 | (col & 0xf0) << 8 |\n\t\t\t(col & 0xf00) << 8 | (col & 0xf00) << 12 |\n\t\t\t(col & 0xf000) << 12 | (col & 0xf000) << 16);\n\t}\n\n\t/**\n\t * Parses a color, always in 32-bit RGBA format.\n\t * @param col {number|string} either a 12-bit number (0xrgb0), a 32-bit number (0xaabbggrr)\n\t * or a string (#rgb, #rrggbb, #rrggbbaa).\n\t * @returns {number} the color in 32-bit RGBA format.\n\t */\n\tstatic parse(col: string|number): number {\n\t\tif (typeof col === 'string') {\n\t\t\tif (col.charAt(0) !== '#') col = ''; // fail\n\n\t\t\t// Invert byte order\n\t\t\tswitch (col.length) {\n\t\t\tcase 4:\n\t\t\t\tcol = parseInt(col.substring(1), 16);\n\t\t\t\treturn color32.extendColor12(col << 4 | 0xf);\n\t\t\tcase 5:\n\t\t\t\tcol = parseInt(col.substring(1), 16);\n\t\t\t\treturn color32.extendColor12(col);\n\t\t\tcase 7:\n\t\t\t\tcol = parseInt(col.substring(1), 16);\n\t\t\t\t// Pass a RGBA with alpha=ff\n\t\t\t\treturn color32.reverseColor32(col << 8 | 0xff);\n\t\t\tcase 9:\n\t\t\t\tcol = parseInt(col.substring(1), 16);\n\t\t\t\treturn color32.reverseColor32(col);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid color string ${col}`);\n\t\t\t}\n\t\t}\n\n\t\tif (col <= 0xffff) {\n\t\t\t// 16-bit to 32\n\t\t\treturn color32.extendColor12(col);\n\t\t}\n\t\telse if (col <= 0xffffff) {\n\t\t\t// 24-bit to 32\n\t\t\treturn col | 0xff << 24;\n\t\t}\n\t\treturn col;\n\t}\n\n\t/**\n\t * @param c {number} color to affect\n\t * @param bitsPerComponent {number} can be 2, 3, 4, 5 to return a reduced color value (x bits per component)\n\t */\n\tstatic posterize(c: number, bitsPerComponent: number) {\n\t\tif (bitsPerComponent === 2) {\n\t\t\tlet hiBits = (c >>> 6 & 0x01010101) | (c >>> 7 & 0x01010101);\n\t\t\thiBits |= hiBits << 1;\n\t\t\tc = c >>> 6 & 0x03030303;\n\t\t\treturn hiBits | hiBits << 2 | c << 4 | c << 6;\n\t\t} else if (bitsPerComponent === 3) {\n\t\t\tconst hiBits = c >>> 6 & 0x03030303;\n\t\t\tc = (c >>> 5 & 0x07070707);\n\t\t\treturn c | c << 5 | c << 2 | hiBits;\n\t\t} else if (bitsPerComponent === 4) {\n\t\t\tc = (c >>> 4 & 0x0f0f0f0f);\n\t\t\treturn c | c << 4;\n\t\t} else if (bitsPerComponent === 5) {\n\t\t\tconst hiBits = (c >>> 5 & 0x07070707);\n\t\t\tc = (c >>> 3 & 0x1f1f1f1f);\n\t\t\treturn c | c << 3 | hiBits;\n\t\t}\n\t\treturn c;\n\t}\n\n\t/**\n\t * Reverses the byte order of a RGBA color.\n\t * @param col {number}\n\t * @returns {number}\n\t */\n\tstatic reverseColor32(col: number): number {\n\t\treturn (col & 0xff) << 24 | (col >>> 8 & 0xff) << 16 | (col >>> 16 & 0xff) << 8 | (col >>> 24 & 0xff);\n\t}\n\n\tstatic add(c: number, d: number): number {\n\t\tlet a = (c >>> 24) + (d >>> 24);\n\t\tlet b = ((c >>> 16) & 0xff) + ((d >>> 16) & 0xff);\n\t\tlet g = ((c >>> 8) & 0xff) + ((d >>> 8) & 0xff);\n\t\tlet r = (c & 0xff) + (d & 0xff);\n\t\tif (a > 255) a = 255;\n\t\tif (b > 255) b = 255;\n\t\tif (g > 255) g = 255;\n\t\tif (r > 255) r = 255;\n\t\treturn r | g << 8 | b << 16 | a << 24;\n\t}\n\n\tstatic sub(c: number, d: number): number {\n\t\tlet a = (c >>> 24) - (d >>> 24);\n\t\tlet b = ((c >>> 16) & 0xff) - ((d >>> 16) & 0xff);\n\t\tlet g = ((c >>> 8) & 0xff) - ((d >>> 8) & 0xff);\n\t\tlet r = (c & 0xff) - (d & 0xff);\n\t\tif (a < 0) a = 0;\n\t\tif (b < 0) b = 0;\n\t\tif (g < 0) g = 0;\n\t\tif (r < 0) r = 0;\n\t\treturn r | g << 8 | b << 16 | a << 24;\n\t}\n\n\tstatic mul(c: number, d: number): number {\n\t\tlet a = ((c >>> 24) * (d >>> 24)) / 255;\n\t\tlet b = ((c >>> 16) & 0xff) * ((d >>> 16) & 0xff) / 255;\n\t\tlet g = ((c >>> 8) & 0xff) * ((d >>> 8) & 0xff) / 255;\n\t\tlet r = (c & 0xff) * (d & 0xff) / 255;\n\t\treturn r | g << 8 | b << 16 | a << 24;\n\t}\n\n\tstatic blend(c: number, d: number, factor: number): number {\n\t\tfactor = Math.min(1, Math.max(0, factor));\n\t\tconst invF = 1 - factor;\n\n\t\tconst a = (c >>> 24) * invF + (d >>> 24) * factor;\n\t\tconst b = ((c >>> 16) & 0xff) * invF + ((d >>> 16) & 0xff) * factor;\n\t\tconst g = ((c >>> 8) & 0xff) * invF + ((d >>> 8) & 0xff) * factor;\n\t\tconst r = (c & 0xff) * invF + (d & 0xff) * factor;\n\t\treturn r | g << 8 | b << 16 | a << 24;\n\t}\n}\n","import { LoadedTexture, readFromTexture32 } from \"./utils\";\nimport { color32 } from './color32';\n\n/**\n * Typed buffer that represents a texture stored in RAM. Contrary to the OpenGL textures, the type doesn't need to be\n * 32-bit integers. You may pass 8, 16 or 32 bit data, and depending on that, you can read/write data with the\n * equivalent type.\n */\nexport class ShadowTexture {\n\tpublic readonly buffer: Uint8Array|Uint16Array|Uint32Array;\n\tpublic readonly width: number;\n\tpublic readonly height: number;\n\tprivate readonly pixelsPerTexel: number;\n\tprivate posterizeToBpp: number = -1;\n\n\t/**\n\t * @param buffer {Uint8Array|Uint16Array|Uint32Array} original texture to construct this shadow texture from (no copy made! use .slice() if required).\n\t * @param width {number} width of the original texture (in texels)\n\t * @param height {number} height of this texture (in texels)\n\t * @param pixelsPerTexel {number}\n\t */\n\tconstructor(buffer: Uint8Array|Uint16Array|Uint32Array, width: number, height: number, pixelsPerTexel: number) {\n\t\t/** @type {Uint8Array|Uint16Array|Uint32Array} */\n\t\tthis.buffer = buffer;\n\t\t/** @type {number} */\n\t\tthis.width = width;\n\t\t/** @type {number} */\n\t\tthis.height = height;\n\t\t/** @type {number} */\n\t\tthis.pixelsPerTexel = pixelsPerTexel;\n\t}\n\n\t/**\n\t * @returns {ShadowTexture} deep copy\n\t */\n\tclone(): ShadowTexture {\n\t\tconst result = new ShadowTexture(this.buffer.slice(0), this.width, this.height, this.pixelsPerTexel);\n\t\tresult.posterizeToBpp = this.posterizeToBpp;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Reads a part of the shadow texture in typed units into a buffer (which needs to be of the same type that this\n\t * ShadowTexture). The buffer is tightly packed (h lines of w typed elements).\n\t */\n\treadToBuffer(x: number, y: number, w: number, h: number, result: Uint8Array|Uint16Array|Uint32Array) {\n\t\tif (typeof this.buffer !== typeof result) throw new Error('readFromShadowTexture: dest buffer must be of same type');\n\n\t\tconst texWidth = this.width * this.pixelsPerTexel;\n\t\tlet src = x + y * texWidth, dst = 0;\n\t\tfor (let i = 0; i < h; i++) {\n\t\t\tresult.set(this.buffer.subarray(src, src + w), dst);\n\t\t\tsrc += texWidth;\n\t\t\tdst += w;\n\t\t}\n\t}\n\n\t/**\n\t * Enables automatic posterization when writing from this ShaowedTexture to the VRAM. You can either pass -1 to\n\t * disable it or pass a number of 2, 3, 4 or 5 (meaning that many bits per RGBA component).\n\t */\n\tsetPosterization(bitsPerPixel: number) {\n\t\tif (this.buffer.constructor !== Uint32Array) throw new Error('Posterization only available for color buffers (32-bit)');\n\t\tthis.posterizeToBpp = bitsPerPixel;\n\t}\n\n\t/**\n\t * Writes data to the shadow texture. The data is tightly a packed buffer (h lines of w typed elements) of the same\n\t * type as this ShadowTexture.\n\t */\n\twriteTo(x, y, w, h, data) {\n\t\tif (typeof this.buffer !== typeof data) throw new Error('writeToShadowTexture: data must be of same type');\n\n\t\tconst texWidth = this.width * this.pixelsPerTexel;\n\t\tlet src = 0, dst = x + y * texWidth;\n\t\tfor (let i = 0; i < h; i++) {\n\t\t\tthis.buffer.set(data.subarray(src, src + w), dst);\n\t\t\tsrc += w;\n\t\t\tdst += texWidth;\n\t\t}\n\t}\n\n\t/**\n\t * Updates surrounding pixels accordingly so that the memory write is 32-bit aligned.\n\t * @param gl {WebGLRenderingContext}\n\t * @param texture {WebGLTexture} destination texture\n\t * @param x {number} portion to write (top-left) in texel coordinates (32-bit)\n\t * @param y {number} portion to write (top-left) in texel coordinates (32-bit)\n\t * @param w {number} number of pixels to write in texels\n\t * @param h {number} number of pixels to write in texels\n\t */\n\tsyncToVramTexture(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number) {\n\t\t// Align width (upper) and x (lower, need an extra column)\n\t\tw = Math.ceil(w / this.pixelsPerTexel);\n\t\tif (x % this.pixelsPerTexel > 0) w += 1;\n\t\tx = Math.floor(x / this.pixelsPerTexel);\n\n\t\t// TODO Florian -- super inefficient because WebGL 1 doesn't support gl.PACK_ROW_LENGTH, so we have to create a separate buffer\n\t\t// The buffer needs to have a stride of w (the width of the sub-image) while we have a buffer with a stride of this.width.\n\t\tconst tightlyPackedBuffer = new Uint32Array(w * h);\n\t\tconst view = new Uint32Array(this.buffer.buffer);\n\t\tconst temp = new ShadowTexture(view, this.width, this.height, 1);\n\t\ttemp.readToBuffer(x, y, w, h, tightlyPackedBuffer);\n\n\t\tif (this.posterizeToBpp >= 1) {\n\t\t\tfor (let i = 0; i < tightlyPackedBuffer.length; i++) {\n\t\t\t\ttightlyPackedBuffer[i] = color32.posterize(tightlyPackedBuffer[i], this.posterizeToBpp);\n\t\t\t}\n\t\t}\n\n\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\tgl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(tightlyPackedBuffer.buffer));\n\t}\n}\n\nexport function makeShadowFromTexture8(gl: WebGLRenderingContext, tex: LoadedTexture): ShadowTexture {\n\tconst typed = new Uint8Array(readFromTexture32(gl, tex.texture, 0, 0, tex.width, tex.height).buffer);\n\treturn new ShadowTexture(typed, tex.width, tex.height, 4);\n}\n\nexport function makeShadowFromTexture16(gl: WebGLRenderingContext, tex: LoadedTexture): ShadowTexture {\n\tconst typed = new Uint16Array(readFromTexture32(gl, tex.texture, 0, 0, tex.width, tex.height).buffer);\n\treturn new ShadowTexture(typed, tex.width, tex.height, 2);\n}\n\nexport function makeShadowFromTexture32(gl: WebGLRenderingContext, tex: LoadedTexture): ShadowTexture {\n\tconst typed = new Uint32Array(readFromTexture32(gl, tex.texture, 0, 0, tex.width, tex.height).buffer);\n\treturn new ShadowTexture(typed, tex.width, tex.height, 1);\n}\n","import { createDataTextureFloat, loadTexture, writeToTextureFloat } from \"./utils\";\nimport { drawPendingObj, enqueueObj, initObjShaders, makeObjBuffer, ObjBuffer } from \"./sprites\";\nimport { drawPendingMap, enqueueMap, initMapShaders, makeMapBuffer } from \"./maps\";\nimport {\n\tenvColor,\n\tOTHER_TEX_W,\n\tSCREEN_HEIGHT,\n\tSCREEN_WIDTH,\n\tSEMITRANSPARENT_CANVAS,\n\tsetTextureSizes,\n\tUSE_PRIORITIES\n} from \"./shaders\";\nimport { drawOpaquePoly, initOpaquePolyShaders } from \"./generalpolys\";\nimport { Array2D, VdpMap, VdpPalette, VdpSprite } from \"./memory\";\nimport {\n\tmakeShadowFromTexture16,\n\tmakeShadowFromTexture32,\n\tmakeShadowFromTexture8,\n\tShadowTexture\n} from \"./shadowtexture\";\nimport { color32 } from \"./color32\";\nimport { mat3, mat4 } from 'gl-matrix';\n\nexport const DEBUG = true;\n// Specs of the fantasy console, do not modify for now\nconst BG_LIMIT = 4;\nconst TBG_LIMIT = 1;\nconst OBJ1_CELL_LIMIT = 64;\nconst OBJ0_CELL_LIMIT = 256;\n\ntype TransparencyConfigEffect = 'none' | 'color' | 'blend' | 'premult';\ntype TransparencyConfigOperation = 'add' | 'sub';\n\nclass TransparencyConfig {\n\teffect: TransparencyConfigEffect;\n\toperation: TransparencyConfigOperation;\n\tblendSrc: number;\n\tblendDst: number;\n\n\tconstructor(effect: TransparencyConfigEffect, operation: TransparencyConfigOperation, blendSrc: number, blendDst: number) {\n\t\tthis.effect = effect;\n\t\tthis.operation = operation;\n\t\tthis.blendSrc = blendSrc;\n\t\tthis.blendDst = blendDst;\n\t}\n\n\tapply(vdp: VDP) {\n\t\tconst gl = vdp.gl;\n\t\tconst {effect, blendSrc, blendDst, operation} = this;\n\n\t\tenvColor[0] = envColor[1] = envColor[2] = envColor[3] = 1;\n\t\tgl.blendEquation(operation === 'sub' ? gl.FUNC_REVERSE_SUBTRACT : gl.FUNC_ADD);\n\n\t\tif (effect === 'blend') { // Used internally for the fade\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t} else if (effect === 'premult') {\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\t} else if (effect === 'color') {\n\t\t\tconst dst = color32.extract(blendDst, vdp.paletteBpp);\n\t\t\tconst src = color32.extract(blendSrc, vdp.paletteBpp);\n\t\t\t// Background blend factor\n\t\t\tgl.blendColor(dst.r / 255, dst.g / 255, dst.b / 255, dst.a / 255);\n\t\t\t// Source blend factor defined in shader\n\t\t\tenvColor[0] = src.r / 255;\n\t\t\tenvColor[1] = src.g / 255;\n\t\t\tenvColor[2] = src.b / 255;\n\t\t\tenvColor[3] = src.a / 255;\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.CONSTANT_COLOR);\n\t\t\tgl.enable(gl.BLEND);\n\t\t} else {\n\t\t\tgl.disable(gl.BLEND);\n\t\t}\n\t}\n}\n\nexport enum VDPCopySource {\n\tcurrent,\n\trom,\n\tblank,\n}\n\n/**\n * Use this class to provide a transformation for each line of the BG when drawing. You can create many kind of effects\n * using this, look at the samples.\n */\nexport class LineTransformationArray {\n\tbuffer: Float32Array;\n\tlength: number;\n\n\tconstructor() {\n\t\t// 8 floats per item (hack for the last one since mat3 is actually 9 items)\n\t\tthis.length = SCREEN_HEIGHT;\n\t\tthis.buffer = new Float32Array(this.length * 8);\n  }\n\n  getLine(lineNo): mat3 {\n\t  if (lineNo < 0 || lineNo >= this.length) throw new Error(`getLine: index ${lineNo} out of range`);\n\t\treturn mat3.fromValues(this.buffer[lineNo * 8], this.buffer[lineNo * 8 + 1], this.buffer[lineNo * 8 + 2], this.buffer[lineNo * 8 + 3], this.buffer[lineNo * 8 + 4], this.buffer[lineNo * 8 + 5], this.buffer[lineNo * 8 + 6], this.buffer[lineNo * 8 + 7], 1);\n  }\n\n\tsetLine(lineNo, transformation: mat3) {\n\t\tif (lineNo < 0 || lineNo >= this.length) throw new Error(`setLine: index ${lineNo} out of range`);\n\t\tthis.buffer.set((transformation as Float32Array).subarray(0, 8), lineNo * 8);\n\t}\n}\n\nconst NO_TRANSPARENCY = new TransparencyConfig('none', 'add', 0, 0);\nconst STANDARD_TRANSPARENCY = new TransparencyConfig('blend', 'add', 0, 0);\n\nexport class VDP {\n\tgl: WebGLRenderingContext;\n\tgameData: any;\n\tmapProgram: any;\n\tmodelViewMatrix: mat3;\n\tprojectionMatrix: mat4;\n\tspriteProgram: any;\n\topaquePolyProgram: any;\n\tmapTexture: WebGLTexture;\n\tpaletteTexture: WebGLTexture;\n\tspriteTexture: WebGLTexture;\n\totherTexture: WebGLTexture;\n\n\t// Fade color (factor is the upper 8 bits).\n\tprivate fadeColor = 0x00000000;\n\tprivate bgTransparency = new TransparencyConfig('color', 'add', 0x888888, 0x888888);\n\tprivate objTransparency = new TransparencyConfig('color', 'add', 0x888888, 0x888888);\n\tprivate bgBuffer = makeMapBuffer('Opaque BG [BG]', BG_LIMIT);\n\tprivate tbgBuffer = makeMapBuffer('Transparent BG [TBG]', TBG_LIMIT);\n\tprivate obj0Buffer = makeObjBuffer('Opaque sprites [OBJ0]', 480);\n\tprivate obj1Buffer = makeObjBuffer('Transparent sprites [OBJ1]', 32);\n\tprivate stats = {\n\t\tpeakOBJ0: 0,\n\t\tpeakOBJ1: 0,\n\t\tpeakBG: 0,\n\t\tOBJ0Limit: OBJ0_CELL_LIMIT\n\t};\n\tprivate frameStarted = true;\n\t// 2 = 64 colors (SMS), 3 = 512 colors (Mega Drive), 4 = 4096 (System 16), 5 = 32k (SNES), 8 = unmodified (PC)\n\tpublic paletteBpp;\n\t// Original data (ROM) for sprites\n\tprivate romSpriteTex: ShadowTexture;\n\t// Copy of the VRAM data for fast read access from the program\n\tprivate shadowSpriteTex: ShadowTexture;\n\tprivate romPaletteTex: ShadowTexture;\n\tprivate shadowPaletteTex: ShadowTexture;\n\tprivate romMapTex: ShadowTexture;\n\tprivate shadowMapTex: ShadowTexture;\n\tprivate nextLinescrollBuffer: number = 0;\n\n\tconstructor(canvas: HTMLCanvasElement, done: () => void) {\n\t\tthis._initContext(canvas);\n\t\tthis._initMatrices();\n\n\t\tconst gl = this.gl;\n\t\t// TODO Florian -- run all requests at the same time and wait for them all.\n\t\twindow.fetch('build/game.json').then((res) => {\n\t\t\tif (!res.ok) throw new Error('You need to build your project first; run `npm run convert-gfx`.')\n\t\t\treturn res.json();\n\t\t}).then((json) => {\n\t\t\tthis.gameData = json;\n\t\t\tthis.paletteBpp = json.info.paletteBpp;\n\t\t\tif ([2, 3, 4, 5, 8].indexOf(this.paletteBpp) === -1) throw new Error(`Unsupported paletteBpp ${this.paletteBpp}`);\n\n\t\t\tloadTexture(gl, 'build/sprites.png').then(sprites => {\n\t\t\t\tthis.spriteTexture = sprites.texture;\n\t\t\t\tthis.romSpriteTex = makeShadowFromTexture8(gl, sprites);\n\t\t\t\tthis.shadowSpriteTex = this.romSpriteTex.clone();\n\n\t\t\t\tloadTexture(gl, 'build/palettes.png').then(palettes => {\n\t\t\t\t\tif (!(palettes.width === 256 && palettes.height === 64) && !(palettes.width === 16 && palettes.height === 256))\n\t\t\t\t\t\tthrow new Error('Mismatch in texture size (max {16,256}x256');\n\t\t\t\t\tthis.paletteTexture = palettes.texture;\n\t\t\t\t\tthis.romPaletteTex = makeShadowFromTexture32(gl, palettes);\n\t\t\t\t\tthis.shadowPaletteTex = this.romPaletteTex.clone();\n\t\t\t\t\tif (this.paletteBpp !== 8) this.shadowPaletteTex.setPosterization(this.paletteBpp);\n\n\t\t\t\t\tloadTexture(gl, 'build/maps.png').then(maps => {\n\t\t\t\t\t\tthis.mapTexture = maps.texture;\n\t\t\t\t\t\tthis.romMapTex = makeShadowFromTexture16(gl, maps);\n\t\t\t\t\t\tthis.shadowMapTex = this.romMapTex.clone();\n\n\t\t\t\t\t\tsetTextureSizes(palettes.width, palettes.height, maps.width, maps.height, sprites.width, sprites.height);\n\n\t\t\t\t\t\tthis.otherTexture = createDataTextureFloat(gl, OTHER_TEX_W, OTHER_TEX_W);\n\t\t\t\t\t\t// Startup color\n\t\t\t\t\t\tthis.configBDColor('#008');\n\n\t\t\t\t\t\tinitMapShaders(this);\n\t\t\t\t\t\tinitObjShaders(this);\n\t\t\t\t\t\tinitOpaquePolyShaders(this);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Configures the backdrop (background color that is always present).\n\t * Note that the backdrop is exactly the first color of the first palette. You can therefore modify it by writing\n\t * to that palette color too. It can become handy when you are doing fades by modifying all colors.\n\t * @param color backdrop color\n\t */\n\tconfigBDColor(color: number|string) {\n\t\tthis.shadowPaletteTex.buffer[0] = color32.parse(color);\n\t}\n\n\t/**\n\t * Configure transparent background effect.\n\t * @param opts\n\t * @param opts.op 'add' or 'sub'\n\t * @param opts.blendSrc source tint (quantity of color to take from the blending object)\n\t * @param opts.blendDst destination tint (quantity of color to take from the backbuffer when mixing)\n\t */\n\tconfigBGTransparency(opts: {op: TransparencyConfigOperation, blendSrc: number|string, blendDst: number|string}) {\n\t\tif (opts.op !== 'add' && opts.op !== 'sub') {\n\t\t\tthrow new Error(`Invalid operation ${opts.op}`);\n\t\t}\n\t\tthis.bgTransparency.operation = opts.op;\n\t\tthis.bgTransparency.blendSrc = color32.parse(opts.blendSrc);\n\t\tthis.bgTransparency.blendDst = color32.parse(opts.blendDst);\n\t}\n\n\t/**\n\t * Configures the fade.\n\t * @param color destination color (suggested black or white).\n\t * @param factor between 0 and 255. 0 means disabled, 255 means fully covered. The fade is only visible in\n\t * increments of 16 (i.e. 1-15 is equivalent to 0).\n\t */\n\tconfigFade(color: number|string, factor: number) {\n\t\tfactor = Math.min(255, Math.max(0, factor));\n\t\tthis.fadeColor = (color32.parse(color) & 0xffffff) | (factor << 24);\n\t}\n\n\t/**\n\t * Configure effect for transparent sprites.\n\t * @param opts\n\t * @param opts.op 'add' or 'sub'\n\t * @param opts.blendSrc source tint (quantity of color to take from the blending object)\n\t * @param opts.blendDst destination tint (quantity of color to take from the backbuffer when mixing)\n\t */\n\tconfigOBJTransparency(opts: {op: TransparencyConfigOperation, blendSrc: number|string, blendDst: number|string}) {\n\t\tif (opts.op !== 'add' && opts.op !== 'sub') {\n\t\t\tthrow new Error(`Invalid operation ${opts.op}`);\n\t\t}\n\t\tthis.objTransparency.operation = opts.op;\n\t\tthis.objTransparency.blendSrc = color32.parse(opts.blendSrc);\n\t\tthis.objTransparency.blendDst = color32.parse(opts.blendDst);\n\t}\n\n\t/**\n\t * @param map map to draw (e.g. vdp.map('level1') or just 'level1')\n\t * @param [opts]\n\t * @param opts.palette specific base palette to use (for the normal tiles). Keep in mind that individual map tiles may use the next 15 palettes by setting the bits 12-15 of the tile number.\n\t * @param opts.scrollX horizontal scrolling\n\t * @param opts.scrollY vertical scrolling\n\t * @param opts.winX left coordinate on the screen to start drawing from (default to 0)\n\t * @param opts.winY top coordinate on the screen to start drawing from (default to 0)\n\t * @param opts.winW width after which to stop drawing (defaults to SCREEN_WIDTH)\n\t * @param opts.winH height after which to stop drawing (defaults to SCREEN_HEIGHT)\n\t * @param opts.lineTransform {LineTransformationArray} per-line transformation array\n\t * @param opts.wrap whether to wrap the map at the bounds (defaults to true)\n\t * @param opts.tileset custom tileset to use.\n\t * @param opts.transparent\n\t * @param opts.prio z-order\n\t */\n\tdrawBG(map, opts: {palette?: string|VdpPalette, scrollX?: number, scrollY?: number, winX?: number, winY?: number, winW?: number, winH?: number, lineTransform?: LineTransformationArray, wrap?: boolean, tileset?: string|VdpSprite, transparent?: boolean, prio?: number} = {}) {\n\t\tif (typeof map === 'string') map = this.map(map);\n\t\t// TODO Florian -- no need for such a param, since the user can modify map.designPalette himself…\n\t\t// Maybe the other options could be in the map too… (just beware that they are strings, not actual links to the palette/tileset… but we could typecheck too)\n\t\tconst pal = this._getPalette(opts.hasOwnProperty('palette') ? opts.palette : map.designPalette);\n\t\tconst til = this._getSprite(opts.hasOwnProperty('tileset') ? opts.tileset : map.designTileset);\n\t\tconst scrollX = opts.hasOwnProperty('scrollX') ? opts.scrollX : 0;\n\t\tconst scrollY = opts.hasOwnProperty('scrollY') ? opts.scrollY : 0;\n\t\tlet winX = opts.hasOwnProperty('winX') ? opts.winX : 0;\n\t\tlet winY = opts.hasOwnProperty('winY') ? opts.winY : 0;\n\t\tlet winW = opts.hasOwnProperty('winW') ? opts.winW : (SCREEN_WIDTH - winX);\n\t\tlet winH = opts.hasOwnProperty('winH') ? opts.winH : (SCREEN_HEIGHT - winY);\n\t\tconst wrap = opts.hasOwnProperty('wrap') ? opts.wrap : true;\n\t\tconst prio = opts.prio || 0;\n\t\tconst buffer = opts.transparent ? this.tbgBuffer : this.bgBuffer;\n\n\t\tif (this.bgBuffer.usedLayers + this.tbgBuffer.usedLayers >= BG_LIMIT) {\n\t\t\tif (DEBUG) console.log(`Too many BGs (${this.bgBuffer.usedLayers} opaque, ${this.tbgBuffer.usedLayers} transparent), ignoring drawBG`);\n\t\t\treturn;\n\t\t}\n\n\t\t// To avoid drawing too big quads and them counting toward the BG pixel budget\n\t\twinX = Math.min(SCREEN_WIDTH, Math.max(0, winX));\n\t\twinY = Math.min(SCREEN_HEIGHT, Math.max(0, winY));\n\t\twinW = Math.min(SCREEN_WIDTH - winX, Math.max(0, winW));\n\t\twinH = Math.min(SCREEN_HEIGHT - winY, Math.max(0, winH));\n\n\t\tlet linescrollBuffer = -1;\n\t\tif (opts.lineTransform) {\n\t\t\tlinescrollBuffer = 256 + this.nextLinescrollBuffer;\n\t\t\twriteToTextureFloat(this.gl, this.otherTexture, 0, this.nextLinescrollBuffer++, opts.lineTransform.buffer.length / 4, 1, opts.lineTransform.buffer);\n\t\t}\n\n\t\tenqueueMap(buffer, map.x, map.y, til.x, til.y, map.w, map.h, til.w, til.tw, til.th, winX, winY, winW, winH, scrollX, scrollY, pal.y, til.hiColor, linescrollBuffer, wrap ? 1 : 0, prio);\n\t}\n\n\t/**\n\t * @param sprite {string|VdpSprite} sprite to draw (e.g. vdp.sprite('plumber') or just 'plumber')\n\t * @param x position (X coord)\n\t * @param y position (Y coord)\n\t * @param [opts]\n\t * @param opts.palette specific palette to use (otherwise just uses the design palette of the sprite)\n\t * @param opts.width width on the screen (stretches the sprite compared to sprite.w)\n\t * @param opts.height height on the screen (stretches the sprite compared to sprite.h)\n\t * @param opts.prio priority of the sprite. By default sprites have a priority of 1 (whereas BGs use 0). Note\n\t * that a sprite having the same priority as a BG will appear BEHIND the BG. This allows you to hide objects behind\n\t * background planes.\n\t * @param opts.transparent whether this is a OBJ1 type sprite (with color effects)\n\t */\n\tdrawObj(sprite, x, y, opts: {palette?: string|VdpPalette, width?: number, height?: number, prio?: number, transparent?: boolean} = {}) {\n\t\tif (typeof sprite === 'string') sprite = this.sprite(sprite);\n\t\t// TODO Florian -- no need for such a param, since the user can modify sprite.designPalette himself…\n\t\tconst pal = this._getPalette(opts.hasOwnProperty('palette') ? opts.palette : sprite.designPalette);\n\t\tconst w = opts.hasOwnProperty('width') ? opts.width : sprite.w;\n\t\tconst h = opts.hasOwnProperty('height') ? opts.height : sprite.h;\n\t\tconst prio = opts.prio || 1;\n\t\tconst buffer = opts.transparent ? this.obj1Buffer: this.obj0Buffer;\n\n\t\tenqueueObj(buffer, x, y, x + w, y + h, sprite.x, sprite.y, sprite.x + sprite.w, sprite.y + sprite.h, pal.y, sprite.hiColor, prio);\n\t}\n\n\t/**\n\t * Get and reset the VDP stats.\n\t */\n\tgetStats() {\n\t\tconst result = this.stats;\n\t\tthis.stats = {\n\t\t\tpeakOBJ0: 0,\n\t\t\tpeakOBJ1: 0,\n\t\t\tpeakBG: 0,\n\t\t\tOBJ0Limit: OBJ0_CELL_LIMIT\n\t\t};\n\t\treturn result;\n\t}\n\n\tmap(name: string): VdpMap {\n\t\tconst map = this.gameData.maps[name];\n\t\tif (!map) throw new Error(`Map ${name} not found`);\n\t\treturn new VdpMap(map.x, map.y, map.w, map.h, map.til, map.pal);\n\t}\n\n\tpalette(name: string): VdpPalette {\n\t\tconst pal = this.gameData.pals[name];\n\t\tif (!pal) throw new Error(`Palette ${name} not found`);\n\t\treturn new VdpPalette(pal.y, pal.w, pal.h);\n\t}\n\n\t/**\n\t * @param map name of the map (or map itself). You may also query an arbitrary portion of the map\n\t * memory using new VdpMap(…) or offset an existing map, using vdp.map('myMap').offsetted(…).\n\t * @param source set to vdp.SOURCE_BLANK if you don't care about the current content of\n\t * the memory (you're going to write only and you need a buffer for that), vdp.SOURCE_CURRENT to read the current\n\t * contents of the memory (as was written the last time with writeMap) or vdp.SOURCE_ROM to get the original data\n\t * as downloaded from the cartridge.\n\t * @return a Array2D containing the map data (buffer member is a Uint16Array), each element being the tile number\n\t * in the tileset.\n\t */\n\treadMap(map: string|VdpMap, source = VDPCopySource.current): Array2D {\n\t\tconst m = this._getMap(map);\n\t\tconst result = new Uint16Array(m.w * m.h);\n\t\tif (source === VDPCopySource.current) this.shadowMapTex.readToBuffer(m.x, m.y, m.w, m.h, result);\n\t\tif (source === VDPCopySource.rom) this.romMapTex.readToBuffer(m.x, m.y, m.w, m.h, result);\n\t\treturn new Array2D(result, m.w, m.h);\n\t}\n\n\t/**\n\t * @param palette name of the palette (or palette itself). You may also query an arbitrary portion\n\t * of the palette memory using new VdpPalette(…) or offset an existing map, using vdp.map('myMap').offsetted(…).\n\t * @param source look at readMap for more info.\n\t * @return {Array2D} an array containing the color entries, encoded as 0xAABBGGRR\n\t */\n\treadPalette(palette: string|VdpPalette, source = VDPCopySource.current): Array2D {\n\t\tconst pal = this._getPalette(palette);\n\t\treturn this.readPaletteMemory(0, pal.y, pal.w, pal.h, source);\n\t}\n\n\t/**\n\t * @param x\n\t * @param y\n\t * @param w\n\t * @param h\n\t * @param source look at readMap for more info.\n\t * @return a Array2D that contains color entries, encoded as 0xAABBGGRR\n\t */\n\treadPaletteMemory(x: number, y: number, w: number, h: number, source = VDPCopySource.current): Array2D {\n\t\tconst result = new Uint32Array(w * h);\n\t\tif (source === VDPCopySource.current) this.shadowPaletteTex.readToBuffer(x, y, w, h, result);\n\t\tif (source === VDPCopySource.rom) this.romPaletteTex.readToBuffer(x, y, w, h, result);\n\t\treturn new Array2D(result, w, h);\n\t}\n\n\t/**\n\t * @param sprite name of the sprite (or sprite itself). You may also query an arbitrary portion of the\n\t * sprite memory using new VdpSprite(…) or offset an existing sprite, using vdp.sprite('mySprite').offsetted(…).\n\t * @param source look at readMap for more info.\n\t * @return a Array2D containing the tileset data. For hi-color sprites, each entry represents one pixel.\n\t * For lo-color sprites, each entry corresponds to two packed pixels, of 4 bits each.\n\t */\n\treadSprite(sprite: string|VdpSprite, source = VDPCopySource.current): Array2D {\n\t\tconst s = this._getSprite(sprite);\n\n\t\tif (!s.hiColor && s.x % 2 !== 0) throw new Error('Lo-color sprites need to be aligned to 2 pixels');\n\t\tconst x = s.hiColor ? s.x : (s.x / 2);\n\t\tconst w = s.hiColor ? s.w : Math.ceil(s.w / 2);\n\n\t\tconst result = new Uint8Array(w * s.h);\n\t\tif (source === VDPCopySource.current) this.shadowSpriteTex.readToBuffer(x, s.y, w, s.h, result);\n\t\tif (source === VDPCopySource.rom) this.romSpriteTex.readToBuffer(x, s.y, w, s.h, result);\n\t\treturn new Array2D(result, w, s.h);\n\t}\n\n\tsprite(name: string): VdpSprite {\n\t\tconst spr = this.gameData.sprites[name];\n\t\tif (!spr) throw new Error(`Sprite ${name} not found`);\n\t\treturn new VdpSprite(spr.x, spr.y, spr.w, spr.h, spr.tw, spr.th, spr.tiles, spr.hicol, spr.pal);\n\t}\n\n\t/**\n\t * @param map {string|VdpMap} name of the map (or map itself). You may also write to an arbitrary portion of the map\n\t * memory using new VdpMap(…) or offset an existing map, using vdp.map('myMap').offsetted(…).\n\t * @param data {Array2D} map data to write (use readMap to create a buffer like that)\n\t */\n\twriteMap(map: string|VdpMap, data: Array2D) {\n\t\tconst m = this._getMap(map);\n\t\tthis.shadowMapTex.writeTo(m.x, m.y, m.w, m.h, data.buffer);\n\t\tthis.shadowMapTex.syncToVramTexture(this.gl, this.mapTexture, m.x, m.y, m.w, m.h);\n\t}\n\n\t/**\n\t * @param palette\n\t * @param data {Array2D} color entries, encoded as 0xAABBGGRR\n\t */\n\twritePalette(palette: string|VdpPalette, data: Array2D) {\n\t\tconst pal = this._getPalette(palette);\n\t\tthis.writePaletteMemory(0, pal.y, pal.w, pal.h, data);\n\t}\n\n\t/**\n\t *\n\t * @param x\n\t * @param y\n\t * @param w\n\t * @param h\n\t * @param data {Array2D} color entries, encoded as 0xAABBGGRR\n\t */\n\twritePaletteMemory(x: number, y: number, w: number, h: number, data: Array2D) {\n\t\tthis.shadowPaletteTex.writeTo(x, y, w, h, data.buffer);\n\t\tthis.shadowPaletteTex.syncToVramTexture(this.gl, this.paletteTexture, x, y, w, h);\n\t}\n\n\t/**\n\t * @param sprite name of the sprite (or sprite itself). You may also write to an arbitrary portion\n\t * of the sprite memory using new VdpSprite(…) or offset an existing sprite, using vdp.sprite('mySprite').offsetted(…).\n\t * @param data {Array2D} the new data. For hi-color sprites, each entry represents one pixel. For lo-color sprites,\n\t * each entry corresponds to two packed pixels, of 4 bits each.\n\t */\n\twriteSprite(sprite: string|VdpSprite, data: Array2D) {\n\t\tconst s = this._getSprite(sprite);\n\n\t\tif (!s.hiColor && s.x % 2 !== 0) throw new Error('Lo-color sprites need to be aligned to 2 pixels');\n\t\tconst x = s.hiColor ? s.x : (s.x / 2);\n\t\tconst w = s.hiColor ? s.w : Math.ceil(s.w / 2);\n\n\t\tthis.shadowSpriteTex.writeTo(x, s.y, w, s.h, data.buffer);\n\t\tthis.shadowSpriteTex.syncToVramTexture(this.gl, this.paletteTexture, x, s.y, w, s.h);\n\t}\n\n\t// --------------------- PRIVATE ---------------------\n\n\t// Take one frame in account for the stats. Read with _readStats.\n\tprivate _computeStats(obj0Limit: number) {\n\t\tthis.stats.peakBG = Math.max(this.stats.peakBG, this.bgBuffer.usedLayers + this.tbgBuffer.usedLayers);\n\t\tthis.stats.peakOBJ0 = Math.max(this.stats.peakOBJ0, this._totalUsedOBJ0());\n\t\tthis.stats.peakOBJ1 = Math.max(this.stats.peakOBJ1, this._totalUsedOBJ1());\n\t\tthis.stats.OBJ0Limit = Math.min(this.stats.OBJ0Limit, obj0Limit);\n\t}\n\n\t/**\n\t * Renders the machine in the current state. Only available for the extended version of the GPU.\n\t */\n\tprivate _doRender() {\n\t\tconst gl = this.gl;\n\t\t// Do before drawing stuff since it flushes the buffer\n\t\tif (DEBUG) this._computeStats(OBJ0_CELL_LIMIT);\n\n\t\t// Only the first time per frame (allow multiple render per frames)\n\t\tif (this.frameStarted) {\n\t\t\tconst clearColor = color32.extract(this.shadowPaletteTex.buffer[0], this.paletteBpp);\n\t\t\tgl.clearColor(clearColor.r / 255, clearColor.g / 255, clearColor.b / 255, 0);\n\n\t\t\tif (USE_PRIORITIES) {\n\t\t\t\tgl.clearDepth(1.0);\t\t\t\t // Clear everything\n\t\t\t\t// PERF: This is a lot slower if there's a discard in the fragment shader (and we need one?) because the GPU can't test & write to the depth buffer until after the fragment shader has been executed. So there's no point in using it I guess.\n\t\t\t\tgl.enable(gl.DEPTH_TEST);\t\t   // Enable depth testing\n\t\t\t\tgl.depthFunc(gl.LESS);\t\t\t// Near things obscure far things\n\t\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\t\t\t} else {\n\t\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\t\t}\n\n\t\t\tthis.frameStarted = false;\n\t\t}\n\n\t\t// OBJ0 and BG (both opaque, OBJ0 first to appear above\n\t\tNO_TRANSPARENCY.apply(this);\n\t\tmat3.identity(this.modelViewMatrix);\n\t\tdrawPendingMap(this, this.bgBuffer);\n\t\tthis._drawObjLayer(this.obj0Buffer, OBJ0_CELL_LIMIT);\n\n\t\t// TBG then OBJ1\n\t\tthis.bgTransparency.apply(this);\n\t\tgl.depthMask(false);\n\t\tdrawPendingMap(this, this.tbgBuffer);\n\t\tgl.depthMask(true);\n\n\t\t// Draw in reverse order\n\t\tthis.obj1Buffer.sort();\n\t\tthis.objTransparency.apply(this);\n\t\tthis._drawObjLayer(this.obj1Buffer, OBJ1_CELL_LIMIT);\n\n\t\tthis.nextLinescrollBuffer = 0;\n\t}\n\n\t/**\n\t * @param objBuffer {ObjBuffer}\n\t * @param objLimit {number} max number of cells drawable\n\t * @private\n\t */\n\tprivate _drawObjLayer(objBuffer: ObjBuffer, objLimit: number = 0) {\n\t\t// Use config only for that poly list\n\t\tmat3.identity(this.modelViewMatrix);\n\t\tdrawPendingObj(this, objBuffer, objLimit);\n\t\tmat3.identity(this.modelViewMatrix);\n\t}\n\n\tpublic _endFrame() {\n\t\tthis._doRender();\n\n\t\t// Draw fade\n\t\tif (this.fadeColor >>> 24 >= 0x10) {\n\t\t\tconst gl = this.gl;\n\t\t\tconst {r, g, b, a} = color32.extract(this.fadeColor, this.paletteBpp);\n\n\t\t\tSTANDARD_TRANSPARENCY.apply(this);\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\tdrawOpaquePoly(this, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, r / 255, g / 255, b / 255, a / 255);\n\t\t}\n\t}\n\n\tprivate _getMap(name: string|VdpMap): VdpMap {\n\t\tif (typeof name === 'string') return this.map(name);\n\t\treturn name;\n\t}\n\n\tprivate _getPalette(name: string|VdpPalette): VdpPalette {\n\t\tif (typeof name === 'string') return this.palette(name);\n\t\treturn name;\n\t}\n\n\tprivate _getSprite(name: string|VdpSprite): VdpSprite {\n\t\tif (typeof name === 'string') return this.sprite(name);\n\t\treturn name;\n\t}\n\n\tprivate _initContext(canvas: HTMLCanvasElement) {\n\t\tthis.gl = canvas.getContext(\"webgl\", { premultipliedAlpha: true, alpha: SEMITRANSPARENT_CANVAS });\n\n\t\t// Only continue if WebGL is available and working\n\t\tif (this.gl === null) {\n\t\t\talert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n\t\t}\n\t}\n\n\tprivate _initMatrices() {\n\t\tthis.projectionMatrix = mat4.create();\n\t\t// note: glmatrix.js always has the first argument as the destination to receive the result.\n\t\tmat4.ortho(this.projectionMatrix, 0.0, SCREEN_WIDTH, SCREEN_HEIGHT, 0.0, -10, 10);\n\n\t\t// Normally set in modelViewMatrix, but we want to allow an empty model view matrix\n\t\t//mat4.translate(this.projectionMatrix, this.projectionMatrix, [-0.0, 0.0, -0.1]);\n\n\t\tthis.modelViewMatrix = mat3.create();\n\t\t// mat4.translate(this.modelViewMatrix, this.modelViewMatrix, [-0.0, 0.0, -0.1]);\n\t}\n\n\tpublic _startFrame() {\n\t\tthis.frameStarted = true;\n\t}\n\n\tprivate _totalUsedOBJ0(): number {\n\t\treturn this.obj0Buffer.computeUsedObjects();\n\t}\n\n\tprivate _totalUsedOBJ1(): number {\n\t\treturn this.obj1Buffer.computeUsedObjects();\n\t}\n}\n","import {initShaderProgram, makeBuffer} from \"./utils\";\nimport { VDP } from './vdp';\n\n// For debugging only\nexport function initOpaquePolyShaders(vdp: VDP) {\n\tconst gl = vdp.gl;\n\t// Vertex shader program\n\tconst vsSource = `\n\t\t\tattribute vec2 aXy;\n\t\t\tattribute vec4 aColor;\n\t\n\t\t\tuniform mat3 uModelViewMatrix;\n\t\t\tuniform mat4 uProjectionMatrix;\n\t\n\t\t\tvarying lowp vec4 vColor;\n\t\t\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uProjectionMatrix * vec4(floor(uModelViewMatrix * vec3(aXy, 0)), 1);\n\t\t\t\tvColor = aColor;\n\t\t\t}\n\t\t`;\n\tconst fsSource = `\n    varying lowp vec4 vColor;\n\n    void main(void) {\n      gl_FragColor = vColor;\n    }\n  `;\n\n\tconst TOTAL_VERTICES = 1 * 4;\n\tconst shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n\n\tvdp.opaquePolyProgram = {\n\t\tprogram: shaderProgram,\n\t\tarrayBuffers: {\n\t\t\txy: new Float32Array(TOTAL_VERTICES * 2),\n\t\t\t// TODO Florian -- Use u8 if possible\n\t\t\tcolor: new Float32Array(TOTAL_VERTICES * 4)\n\t\t},\n\t\tattribLocations: {\n\t\t\txy: gl.getAttribLocation(shaderProgram, 'aXy'),\n\t\t\tcolor: gl.getAttribLocation(shaderProgram, 'aColor'),\n\t\t},\n\t\tglBuffers: {\n\t\t\txy: makeBuffer(gl),\n\t\t\tcolor: makeBuffer(gl)\n\t\t},\n\t\tuniformLocations: {\n\t\t\tprojectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\n\t\t\tmodelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\n\t\t},\n\t};\n}\n\n// Color is float (r, g, b, a) between 0 and 1\nexport function drawOpaquePoly(vdp: VDP, xStart: number, yStart: number, xEnd: number, yEnd: number, colorR: number, colorG: number, colorB: number, colorA: number) {\n\tconst gl = vdp.gl;\n\tconst prog = vdp.opaquePolyProgram;\n\tconst positions = [\n\t\txStart, yStart,\n\t\txEnd, yStart,\n\t\txStart, yEnd,\n\t\txEnd, yEnd,\n\t];\n\t// TODO Florian -- use indexed vertices\n\tconst colors = [\n\t\tcolorR, colorG, colorB, colorA,\n\t\tcolorR, colorG, colorB, colorA,\n\t\tcolorR, colorG, colorB, colorA,\n\t\tcolorR, colorG, colorB, colorA,\n\t];\n\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xy);\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STREAM_DRAW);\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.color);\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STREAM_DRAW);\n\n\tgl.useProgram(prog.program);\n\t{\n\t\tconst numComponents = 2;  // pull out 4 values per iteration\n\t\tconst type = gl.FLOAT;    // the data in the buffer is 32bit floats\n\t\tconst normalize = false;  // don't normalize\n\t\tconst stride = 0;         // how many bytes to get from one set of values to the next\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 0 = use type and numComponents above\n\t\tconst offset = 0;         // how many bytes inside the buffer to start from\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xy);\n\t\tgl.vertexAttribPointer(prog.attribLocations.xy, numComponents, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.xy);\n\t}\n\t{\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.color);\n\t\tgl.vertexAttribPointer(prog.attribLocations.color, num, type, normalize, stride, offset);\n\t\tgl.enableVertexAttribArray(prog.attribLocations.color);\n\t}\n\n\t// Set the shader uniforms\n\tgl.uniformMatrix4fv(prog.uniformLocations.projectionMatrix, false, vdp.projectionMatrix);\n\tgl.uniformMatrix3fv(prog.uniformLocations.modelViewMatrix,false, vdp.modelViewMatrix);\n\n\t{\n\t\tconst offset = 0;\n\t\tconst vertexCount = 4;\n\t\tgl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\n\t}\n}\n\n","// Framerate expectations (works OK on a 60 Hz display; if you have a higher resolution display, you may want to set MIN_ACCEPTABLE_DT=REGULAR_DT=MAX_ACCEPTABLE_DT)\nexport const NOMINAL_FRAMERATE = 59.94;\nconst MIN_ACCEPTABLE_DT = 1 / (NOMINAL_FRAMERATE + 1);\nconst REGULAR_DT = 1 / NOMINAL_FRAMERATE;\nconst MAX_ACCEPTABLE_DT = 1 / (NOMINAL_FRAMERATE - 1);\nconst MAX_LATE = 1 / 4.0;\nconst FRAMERATE_SAMPLES = 30;\n\nexport class FramerateAdjuster {\n\tpublic last = 0;\n\tpublic late = 0;\n\tprivate framerateSum: number = REGULAR_DT * FRAMERATE_SAMPLES;\n\n\t/**\n\t * Strategy that maximizes smoothness on display close to the target framerate.\n\t * @param timestamp {number} current timestamp (ms)\n\t * @returns {number} the number of frames to render (0..n, the n-1 first should not be rendered).\n\t */\n\tdoForSmoothness(timestamp: number): number {\n\t\tconst diff = this._timeDiff(timestamp);\n\t\tthis._addToFramerate(diff);\n\n\t\tif (diff > MAX_ACCEPTABLE_DT) {\n\t\t\tthis.late += diff - MAX_ACCEPTABLE_DT;\n\t\t\tif (this.late > MAX_LATE) this.late = 0;\n\t\t} else if (diff < MIN_ACCEPTABLE_DT) {\n\t\t\tthis.late += diff - MIN_ACCEPTABLE_DT;\n\t\t}\n\n\t\tthis.last = timestamp;\n\n\t\tif (this.late <= -REGULAR_DT) {\n\t\t\tthis.late += REGULAR_DT;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (this.late >= REGULAR_DT) {\n\t\t\t\tconst skipFrames = Math.floor(this.late / REGULAR_DT);\n\t\t\t\tthis.late -= skipFrames * REGULAR_DT;\n\t\t\t\treturn 1 + skipFrames;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/**\n\t * Never skips a frame. Use only if you're very close to the target framerate.\n\t * @param timestamp {number} current timestamp (ms)\n\t * @returns {number} the number of frames to render (0..n, the n-1 first should not be rendered).\n\t */\n\tdoSimplest(timestamp: number): number {\n\t\tconst diff = this._timeDiff(timestamp);\n\t\tthis._addToFramerate(diff);\n\t\tthis.last = timestamp;\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Standard frameskipping strategy.\n\t * @param timestamp {number}\n\t * @returns {number} the number of frames to render (0..n, the n-1 first should not be rendered).\n\t */\n\tdoStandard(timestamp: number): number {\n\t\tconst diff = this._timeDiff(timestamp);\n\t\tthis._addToFramerate(diff);\n\n\t\tthis.late += diff - REGULAR_DT;\n\t\tif (this.late > MAX_LATE) this.late = 0;\n\t\tthis.last = timestamp;\n\n\t\tif (this.late >= REGULAR_DT) {\n\t\t\tconst skipFrames = Math.floor(this.late / REGULAR_DT);\n\t\t\tthis.late -= skipFrames * REGULAR_DT;\n\t\t\treturn 1 + skipFrames;\n\t\t}\n\t\telse if (this.late <= -REGULAR_DT) {\n\t\t\tthis.late += REGULAR_DT;\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tgetFramerate(): number {\n\t\treturn FRAMERATE_SAMPLES / this.framerateSum;\n\t}\n\n\t/**\n\t *\n\t * @param diff {number}\n\t * @private\n\t */\n\t_addToFramerate(diff: number) {\n\t\t// Ignore long breaks\n\t\tif (diff < MAX_LATE) {\n\t\t\tthis.framerateSum = this.framerateSum * (FRAMERATE_SAMPLES - 1) / FRAMERATE_SAMPLES + diff;\n\t\t}\n\t}\n\n\t/**\n\t * @param timestamp {number}\n\t * @returns {number}\n\t */\n\t_timeDiff(timestamp: number): number {\n\t\treturn (timestamp - this.last) / 1000;\n\t}\n}\n","import { setParams } from \"./shaders\";\nimport { DEBUG, VDP } from \"./vdp\";\nimport { FramerateAdjuster, NOMINAL_FRAMERATE } from \"./FramerateAdjuster\";\n\nexport function loadVdp(canvas: HTMLCanvasElement): Promise<VDP> {\n\t//canvas.style.width = `${canvas.width * 2}px`;\n\t//canvas.style.height = `${canvas.height * 2}px`;\n\tsetParams(canvas.width, canvas.height, false);\n\treturn new Promise(function (resolve) {\n\t\tconst vdp = new VDP(canvas, () => {\n\t\t\tvdp._startFrame();\n\t\t\tresolve(vdp);\n\t\t});\n\t});\n}\n\nexport function runProgram(vdp: VDP, coroutine: IterableIterator<number>) {\n\t// All in seconds except last\n\tlet lastInt = 0;\n\tconst times = [];\n\tconst framerateAdj = new FramerateAdjuster();\n\tlet renderedFrames = 0, skippedFrames = 0;\n\n\tfunction step(timestamp) {\n\t\tif (DEBUG) {\n\t\t\t// Timestamp is in milliseconds\n\t\t\tconst timestampInt = Math.floor(timestamp / 1000);\n\n\t\t\tif (timestampInt !== lastInt && times.length > 0) {\n\t\t\t\tconsole.log(`Upd=${(times.reduce((a, b) => a + b) / times.length).toFixed(3)}ms; r=${renderedFrames}, s=${skippedFrames}, u=${times.length}; ${framerateAdj.getFramerate().toFixed(2)}Hz`, vdp.getStats());\n\t\t\t\ttimes.length = 0;\n\t\t\t\trenderedFrames = skippedFrames = 0;\n\t\t\t}\n\n\t\t\tlastInt = timestampInt;\n\t\t}\n\n\t\t// The algorithm depends on the refresh rate of the screen. Use smooth if close, use simple otherwise as smooth will produce some speed variations.\n\t\tconst framerate = framerateAdj.getFramerate();\n\t\tlet toRender;\n\t\tif (framerate >= NOMINAL_FRAMERATE - 1 && framerate <= NOMINAL_FRAMERATE + 1) {\n\t\t\ttoRender = framerateAdj.doSimplest(timestamp);\n\t\t} else {\n\t\t\ttoRender = framerateAdj.doStandard(timestamp);\n\t\t}\n\n\t\t// Render the expected number of frames\n\t\tfor (let i = 0; i < toRender; i++) {\n\t\t\tconst before = window.performance.now();\n\t\t\tvdp._startFrame();\n\t\t\tcoroutine.next();\n\t\t\tvdp._endFrame();\n\t\t\ttimes.push(window.performance.now() - before);\n\t\t}\n\n\t\tif (DEBUG) {\n\t\t\tif (toRender > 0) renderedFrames += 1;\n\t\t\tif (toRender > 1) skippedFrames += toRender - 1;\n\t\t}\n\t\twindow.requestAnimationFrame(step);\n\t}\n\n\twindow.requestAnimationFrame(step);\n}\n","import { loadVdp, runProgram } from './vdp/runloop';\nimport { VDP, LineTransformationArray } from './vdp/vdp';\n\nexport function startGame(canvas: HTMLCanvasElement, loadedCb: (vdp: VDP) => IterableIterator<number>) {\n\tloadVdp(document.querySelector(\"#glCanvas\"))\n\t\t.then(vdp => runProgram(vdp, loadedCb(vdp)));\n}\n\nexport {\n\tLineTransformationArray\n};\n"],"sourceRoot":""}