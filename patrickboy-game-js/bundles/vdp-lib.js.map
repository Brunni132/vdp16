{"version":3,"sources":["webpack://vdp-lib/webpack/universalModuleDefinition","webpack://vdp-lib/webpack/bootstrap","webpack://vdp-lib/external {\"root\":\"window\",\"commonjs\":\"gl-matrix\",\"commonjs2\":\"gl-matrix\",\"amd\":\"gl-matrix\"}","webpack://vdp-lib/./vdp/shaders.ts","webpack://vdp-lib/./vdp/utils.ts","webpack://vdp-lib/./vdp/sprites.ts","webpack://vdp-lib/./vdp/maps.ts","webpack://vdp-lib/./vdp/memory.ts","webpack://vdp-lib/./vdp/color32.ts","webpack://vdp-lib/./vdp/shadowtexture.ts","webpack://vdp-lib/./vdp/vdp.ts","webpack://vdp-lib/./vdp/generalpolys.ts","webpack://vdp-lib/./vdp/FramerateAdjuster.ts","webpack://vdp-lib/./vdp/runloop.ts","webpack://vdp-lib/./lib-main.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SCREEN_WIDTH","SCREEN_HEIGHT","PALETTE_TEX_W","MAP_TEX_W","MAP_TEX_H","SPRITE_TEX_W","SPRITE_TEX_H","PALETTE_TEX_H","SEMITRANSPARENT_CANVAS","OTHER_TEX_W","OTHER_TEX_H","DISCARD_ALPHA","PALETTE_HICOLOR_FLAG","envColor","declareReadTexel","paletteMultiplier8","paletteMultiplier4","makeOutputColor","colorExpr","OES_texture_float_ext","readPixelsFramebuffer","LoadedTexture","texture","image","this","width","height","loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","deleteShader","initShaderProgram","vsSource","fsSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","loadTexture","url","createTexture","Image","bindTexture","TEXTURE_2D","Promise","resolve","onload","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","REPEAT","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","src","makeBuffer","createBuffer","bindToFramebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","readFromTexture32","x","y","w","h","result","Uint8Array","readPixels","TEMP_MakeDualTriangle","array","stride","concat","apply","slice","OBJ_BUFFER_STRIDE","sprites_ObjBuffer","ObjBuffer","numVertices","usedVertices","xyzp","Float32Array","uv","maxVertices","computeUsedObjects","first","count","firstSprite","usedSprites","computeObjectCells","getSizeOfObject","firstVertice","getZOfObject","index","objectIndex","vert","Math","abs","limitObjList","maxCells","cells","endOfList","size","current","DEBUG","console","log","sort","frontToBack","_this","items","Array","from","length","v","k","a","b","originalXyzp","originalUv","set","subarray","max","ceil","makeObjBuffer","numSprites","BG_BUFFER_STRIDE","MapBuffer","mapInfo1","mapInfo2","mapInfo3","mapInfo4","drawPendingMap","vdp","mapBuffer","prog","mapProgram","bindBuffer","ARRAY_BUFFER","glBuffers","bufferData","STREAM_DRAW","useProgram","program","FLOAT","normalize","offset","vertexAttribPointer","attribLocations","enableVertexAttribArray","num","activeTexture","TEXTURE0","spriteTexture","TEXTURE1","paletteTexture","TEXTURE2","mapTexture","TEXTURE3","otherTexture","uniform1i","uniformLocations","uSamplerSprites","uSamplerPalettes","uSamplerMaps","uSamplerOthers","uniformMatrix4fv","projectionMatrix","uniformMatrix3fv","modelViewMatrix","uniform4f","drawArrays","TRIANGLES","makeMapBuffer","numMaps","VdpMap","designTileset","designPalette","offsetted","VdpPalette","VdpSprite","tw","th","tiles","hiColor","tile","no","columnsPerRow","floor","Error","col","row","Array2D","buffer","getElement","setElement","color32","extract","bitsPerComponent","posterize","g","make","extendColor12","reverseColor32","parse","charAt","parseInt","substring","hiBits","add","sub","mul","blend","factor","invF","min","shadowtexture_ShadowTexture","ShadowTexture","pixelsPerTexel","posterizeToBpp","clone","readToBuffer","texWidth","dst","setPosterization","bitsPerPixel","constructor","Uint32Array","writeTo","data","syncToVramTexture","tightlyPackedBuffer","texSubImage2D","VDPCopySource","vdp_TransparencyConfig","TransparencyConfig","effect","operation","blendSrc","blendDst","blendEquation","FUNC_REVERSE_SUBTRACT","FUNC_ADD","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","paletteBpp","blendColor","CONSTANT_COLOR","disable","vdp_LineTransformationArray","LineTransformationArray","numLines","getLine","lineNo","external_root_window_commonjs_gl_matrix_commonjs2_gl_matrix_amd_gl_matrix_","fromValues","setLine","transformation","NO_TRANSPARENCY","STANDARD_TRANSPARENCY","vdp_VDP","VDP","canvas","done","fadeColor","bgTransparency","objTransparency","bgBuffer","tbgBuffer","obj0Buffer","obj1Buffer","stats","peakOBJ0","peakOBJ1","peakBG","OBJ0Limit","frameStarted","nextLinescrollBuffer","_initContext","_initMatrices","fetch","then","res","json","gameData","info","indexOf","sprites","tex","typed","romSpriteTex","shadowSpriteTex","palettes","romPaletteTex","shadowPaletteTex","maps","paletteTexW","paletteTexH","mapTexW","mapTexH","spriteTexW","spriteTexH","romMapTex","Uint16Array","shadowMapTex","getExtension","full","fill","createDataTextureFloat","configBDColor","getAttribLocation","getUniformLocation","spriteProgram","opaquePolyProgram","arrayBuffers","xy","TOTAL_VERTICES","color","configBGTransparency","opts","op","configFade","configOBJTransparency","drawBG","map","pal","_getPalette","palette","til","_getSprite","tileset","scrollX","scrollY","winX","winY","winW","winH","wrap","prio","transparent","usedLayers","linescrollBuffer","lineTransform","uMap","vMap","uTileset","vTileset","mapWidth","mapHeight","tilesetWidth","tileWidth","tileHeight","palNo","z","enqueueMap","drawObj","sprite","objBuffer","xStart","yStart","xEnd","yEnd","uStart","vStart","uEnd","vEnd","enqueueObj","getStats","pals","readMap","_getMap","rom","readPalette","readPaletteMemory","readSprite","spr","hicol","writeMap","writePalette","writePaletteMemory","writeSprite","_computeStats","obj0Limit","_totalUsedOBJ0","_totalUsedOBJ1","_doRender","clearColor","clearDepth","DEPTH_TEST","depthFunc","LESS","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","identity","_drawObjLayer","depthMask","objLimit","numObjectsToDraw","drawPendingObj","_endFrame","_a","colorR","colorG","colorB","colorA","positions","colors","TRIANGLE_STRIP","drawOpaquePoly","getContext","premultipliedAlpha","alpha","ortho","_startFrame","NOMINAL_FRAMERATE","MIN_ACCEPTABLE_DT","REGULAR_DT","MAX_ACCEPTABLE_DT","FramerateAdjuster","last","late","framerateSum","doForSmoothness","timestamp","diff","_timeDiff","_addToFramerate","skipFrames","doSimplest","doStandard","getFramerate","loadVdp","screenWidth","screenHeight","compositedFramebuffer","startGame","loadedCb","document","querySelector","coroutine","lastInt","times","framerateAdj","skippedFrames","renderedFrames","requestAnimationFrame","step","timestampInt","reduce","toFixed","toRender","framerate","before","performance","now","next","push","__webpack_exports__"],"mappings":"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","file":"vdp-lib.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gl-matrix\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"vdp-lib\", [\"gl-matrix\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vdp-lib\"] = factory(require(\"gl-matrix\"));\n\telse\n\t\troot[\"vdp-lib\"] = factory(root[\"window\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","export let SCREEN_WIDTH, SCREEN_HEIGHT;\r\nexport let MAP_TEX_W = 1024, MAP_TEX_H = 1024;\r\nexport let SPRITE_TEX_W = 1024, SPRITE_TEX_H = 1024;\r\nexport let PALETTE_TEX_W, PALETTE_TEX_H = 256;\r\nexport let SEMITRANSPARENT_CANVAS = false;\r\n\r\nexport const OTHER_TEX_W = 2048, OTHER_TEX_H = 16;\r\n\r\n// Used for limited machine\r\nexport const USE_PRIORITIES = true;\r\n// 4 on limited machine\r\nexport const MAX_BGS = 1;\r\n// True on limited machine, false otherwise\r\nexport const DISCARD_ALPHA = true;\r\n\r\nexport const MAX_SPRITES = 1 << 16;\r\n\r\nexport const PALETTE_HICOLOR_FLAG = 1 << 15;\r\n\r\nexport const envColor: number[] = [1, 1, 1, 1];\r\n\r\nexport function setParams(screenWidth: number, screenHeight: number, compositedFramebuffer: boolean = false) {\r\n\tSCREEN_WIDTH = screenWidth;\r\n\tSCREEN_HEIGHT = screenHeight;\r\n\tSEMITRANSPARENT_CANVAS = compositedFramebuffer;\r\n}\r\n\r\nexport function setTextureSizes(paletteTexW: number, paletteTexH: number, mapTexW: number, mapTexH: number, spriteTexW: number, spriteTexH: number) {\r\n\tPALETTE_TEX_H = paletteTexH;\r\n\tPALETTE_TEX_W = paletteTexW;\r\n\tSPRITE_TEX_W = spriteTexW;\r\n\tSPRITE_TEX_H = spriteTexH;\r\n\tMAP_TEX_W = mapTexW;\r\n\tMAP_TEX_H = mapTexH;\r\n}\r\n\r\nexport function declareReadTexel(): string {\r\n\tconst paletteMultiplier8 = `float(${(255.0 / 256.0) * (256 / PALETTE_TEX_W)})`;\r\n\tconst paletteMultiplier4 = `float(${16.0 / PALETTE_TEX_W / 16.0})`;\r\n\tconst byteMultiplier = '255.0';\r\n\t// Returns a value between 0 and 1, ready to map a color in palette (0..255)\r\n\treturn `\r\n\t\t\tfloat readTexel8(float x, float y) {\r\n\t\t\t\tint texelId = int(x / 4.0);\r\n\t\t\t\tvec4 read = texture2D(uSamplerSprites, vec2(float(texelId) / ${SPRITE_TEX_W}.0, y / ${SPRITE_TEX_H}.0));\r\n\t\t\t\tint texelC = int(x) - texelId * 4;\r\n\t\t\t\tif (texelC == 0) return read.r * ${paletteMultiplier8};\r\n\t\t\t\tif (texelC == 1) return read.g * ${paletteMultiplier8};\r\n\t\t\t\tif (texelC == 2) return read.b * ${paletteMultiplier8};\r\n\t\t\t\treturn read.a * ${paletteMultiplier8};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfloat extractTexelHi(float colorComp) {\r\n\t\t\t\tint intValue = int(colorComp * ${byteMultiplier});\r\n\t\t\t\treturn float(intValue / 16) * ${paletteMultiplier4};\r\n\t\t\t}\r\n\r\n\t\t\tfloat extractTexelLo(float colorComp) {\r\n\t\t\t\tint intValue = int(colorComp * ${byteMultiplier});\r\n\t\t\t\treturn float(intValue - (intValue / 16) * 16) * ${paletteMultiplier4};\r\n\t\t\t\t//return float(mod(float(intValue), 16.0)) * ${paletteMultiplier4};\r\n\t\t\t}\r\n\t\r\n\t\t\tfloat readTexel4(float x, float y) {\r\n\t\t\t\tint texelId = int(x / 8.0);\r\n\t\t\t\tvec4 read = texture2D(uSamplerSprites, vec2(float(texelId) / ${SPRITE_TEX_W}.0, y / ${SPRITE_TEX_H}.0));\r\n\t\t\t\tint texelC = int(x) - texelId * 8;\r\n\t\t\t\t\r\n\t\t\t\tif (texelC == 0) return extractTexelHi(read.r);\r\n\t\t\t\tif (texelC == 1) return extractTexelLo(read.r);\r\n\t\t\t\tif (texelC == 2) return extractTexelHi(read.g);\r\n\t\t\t\tif (texelC == 3) return extractTexelLo(read.g);\r\n\t\t\t\tif (texelC == 4) return extractTexelHi(read.b);\r\n\t\t\t\tif (texelC == 5) return extractTexelLo(read.b);\r\n\t\t\t\tif (texelC == 6) return extractTexelHi(read.a);\r\n\t\t\t\treturn extractTexelLo(read.a);\r\n\t\t\t\t//return 9.0 * ${paletteMultiplier4};\r\n\t\t\t}`;\r\n}\r\n\r\nexport function declareReadPalette(): string {\r\n\t// Can be reused, works and is checked to be 100% equivalent to having a RGBA4444 texture. But beware that makeOutputColor takes in account the envColor but doesn't posterize it, so you may want to move that\r\n\t// return `vec4 readPalette(float x, float y) {\r\n\t// \t\t\tvec4 data = texture2D(uSamplerPalettes, vec2(x, y));\r\n\t// \t\t\t// Checked: same render as pre-posterization\r\n\t// \t\t\treturn floor(data * 16.0) / 15.0;\r\n\t// \t\t}`;\r\n\r\n\t// Can be used to make more intense colors\r\n\t//return `vec4 readPalette(float x, float y) {\r\n\t//\t\t\tvec3 color = texture2D(uSamplerPalettes, vec2(x, y)).rgb;\r\n\t//\t\t\t//vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\r\n\t//\t\t\tvec3 gray = vec3(dot(vec3(0.3,0.5,0.2), color));\r\n\t//\t\t\treturn vec4(mix(color, gray, -0.5), 1);\r\n\t//\t\t}`;\r\n\r\n\treturn `vec4 readPalette(float x, float y) {\r\n\t\t\t\treturn texture2D(uSamplerPalettes, vec2(x, y));\r\n\t\t\t}`;\r\n}\r\n\r\nexport function makeOutputColor(colorExpr: string): string {\r\n\tif (DISCARD_ALPHA) {\r\n\t\treturn `vec4((${colorExpr}).rgb * uEnvColor.rgb, 1)`;\r\n\t}\r\n\treturn `${colorExpr} * uEnvColor`;\r\n}\r\n","import { mat3, mat4, vec3 } from 'gl-matrix';\r\n\r\nlet OES_texture_float_ext: any = null;\r\nlet readPixelsFramebuffer: WebGLFramebuffer = null;\r\n\r\n/**\r\n * @param mat {mat3}\r\n * @returns {vec3}\r\n */\r\nexport function getScalingFactorOfMatrix(mat: mat3): vec3 {\r\n\tconst scaling = vec3.create();\r\n\tconst fullMat = mat4.fromValues(\r\n\t\tmat[0], mat[1], mat[2], 0,\r\n\t\tmat[3], mat[4], mat[5], 0,\r\n\t\tmat[6], mat[7], mat[8], 0,\r\n\t\t0, 0, 0, 1);\r\n\tmat4.getScaling(scaling, fullMat);\r\n\treturn scaling;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Texture\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport class LoadedTexture {\r\n\ttexture: WebGLTexture;\r\n\twidth: number;\r\n\theight: number;\r\n\r\n\tconstructor(texture: WebGLTexture, image: {width: number, height: number}) {\r\n\t\tthis.texture = texture;\r\n\t\tthis.width = image.width;\r\n\t\tthis.height = image.height;\r\n\t}\r\n}\r\n\r\n// export function createDataTexture8(gl, width, height) {\r\n// \tconst texture = gl.createTexture();\r\n// \tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n// \t// const ext = gl.getExtension('WEBGL_depth_texture');\r\n// \t// alert(gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null));\r\n// \tif (width % 4 !== 0) alert(`createDataTexture8: ${width} MUST be mod 4`);\r\n// \tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width / 4, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n// \treturn texture;\r\n// }\r\n\r\n// If you're going to store 8 bits components for instance, divide the width by 4\r\nexport function createDataTexture32(gl: WebGLRenderingContext, width: number, height: number): WebGLTexture {\r\n\tconst texture = gl.createTexture();\r\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\treturn texture;\r\n}\r\n\r\nexport function createDataTextureFloat(gl, width, height): WebGLTexture {\r\n\tif (!OES_texture_float_ext) OES_texture_float_ext = gl.getExtension('OES_texture_float');\r\n\r\n\tconst texture = gl.createTexture();\r\n\tconst full = new Float32Array(width * height * 4);\r\n\tfull.fill(0);\r\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, full);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\treturn texture;\r\n}\r\n\r\n/** creates a shader of the given type, uploads the source and compiles it. */\r\nfunction loadShader(gl: WebGLRenderingContext, type: GLenum, source: string) {\r\n\tconst shader = gl.createShader(type);\r\n\r\n\t// Send the source to the shader object\r\n\r\n\tgl.shaderSource(shader, source);\r\n\r\n\t// Compile the shader program\r\n\r\n\tgl.compileShader(shader);\r\n\r\n\t// See if it compiled successfully\r\n\r\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n\t\talert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n\t\tgl.deleteShader(shader);\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn shader;\r\n}\r\n\r\n/** Initialize a shader program, so WebGL knows how to draw our data. */\r\nexport function initShaderProgram(gl: WebGLRenderingContext, vsSource: string, fsSource: string): WebGLProgram {\r\n\tconst vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n\tconst fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n\r\n\t// Create the shader program\r\n\r\n\tconst shaderProgram = gl.createProgram();\r\n\tgl.attachShader(shaderProgram, vertexShader);\r\n\tgl.attachShader(shaderProgram, fragmentShader);\r\n\tgl.linkProgram(shaderProgram);\r\n\r\n\t// If creating the shader program failed, alert\r\n\r\n\tif (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n\t\talert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn shaderProgram;\r\n}\r\n\r\n/**\r\n * @param gl {WebGLRenderingContext}\r\n * @param url {string}\r\n * @returns {Promise<LoadedTexture>} giving a LoadedTexture\r\n */\r\nexport function loadTexture(gl: WebGLRenderingContext, url: string): Promise<LoadedTexture> {\r\n\tconst texture = gl.createTexture();\r\n\tconst image = new Image();\r\n\r\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\treturn new Promise((resolve) => {\r\n\t\timage.onload = function() {\r\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\t\t\treturn resolve(new LoadedTexture(texture, image));\r\n\t\t};\r\n\t\timage.src = url;\r\n\t});\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Buffer - memory\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport function makeBuffer(gl: WebGLRenderingContext): WebGLBuffer {\r\n\treturn gl.createBuffer();\r\n}\r\n\r\nexport function memcpy(dst, dstOffset, src, srcOffset, length) {\r\n\tconst dstU8 = new Uint8Array(dst, dstOffset, length);\r\n\tconst srcU8 = new Uint8Array(src, srcOffset, length);\r\n\tdstU8.set(srcU8);\r\n}\r\n\r\nfunction bindToFramebuffer(gl: WebGLRenderingContext, texture: WebGLTexture) {\r\n\tif (!readPixelsFramebuffer) {\r\n\t\treadPixelsFramebuffer = gl.createFramebuffer();\r\n\t}\r\n\tif (texture) {\r\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, readPixelsFramebuffer);\r\n\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n\t} else {\r\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param first {number}\r\n * @param n {number}\r\n * @returns {Array} an array with [first, first+1, , first+n-1]\r\n */\r\nexport function makeRangeArray(first: number, n: number): Array<number> {\r\n\treturn Array.from({length: n}, (v, k) => first + k);\r\n\t//return Array.apply(null, {length: n}).map(Number.call, Number)\r\n}\r\n\r\n/**\r\n * @param n {number}\r\n * @returns {Array} an array with [n-1, n-2, , 1, 0]\r\n */\r\nexport function makeReverseRangeArray(n: number): Array<number> {\r\n\treturn Array.from({length: n}, (v, k) => n - 1 - k);\r\n}\r\n\r\n/**\r\n * @param gl\r\n * @param texture\r\n * @param x {number} in texels (4 bytes per texel)\r\n * @param y {number}\r\n * @param w {number} in texels\r\n * @param h {number}\r\n * @returns {Uint8Array}\r\n */\r\nexport function readFromTexture32(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number): Uint8Array {\r\n\tconst result = new Uint8Array(w * h * 4);\r\n\tbindToFramebuffer(gl, texture);\r\n\tgl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, result);\r\n\tbindToFramebuffer(gl, null);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * @param gl\r\n * @param texture\r\n * @param x {number} in texels (4 bytes per texel)\r\n * @param y {number}\r\n * @param w {number} in texels\r\n * @param h {number}\r\n * @param result {Uint8Array}\r\n */\r\nexport function readFromTextureToExisting(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number, result: Uint8Array) {\r\n\tbindToFramebuffer(gl, texture);\r\n\tgl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, result);\r\n\tbindToFramebuffer(gl, null);\r\n}\r\n\r\n/**\r\n * @param gl\r\n * @param texture\r\n * @param x {number} in texels (4 bytes per texel)\r\n * @param y {number}\r\n * @param w {number} in texels\r\n * @param h {number}\r\n * @returns {Float32Array}\r\n */\r\nexport function readFromTextureFloat(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number): Float32Array {\r\n\tconst result = new Float32Array(w * h * 4);\r\n\tbindToFramebuffer(gl, texture);\r\n\tgl.readPixels(x, y, w, h, gl.RGBA, gl.FLOAT, result);\r\n\tbindToFramebuffer(gl, null);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Do not use this for float arrays!\r\n * @param gl\r\n * @param texture\r\n * @param x {number} in texels (4 bytes per texel)\r\n * @param y {number}\r\n * @param w {number} in texels\r\n * @param h {number}\r\n * @param array {Uint8Array}\r\n */\r\nexport function writeToTexture32(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number, array: Uint8Array) {\r\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\tgl.texSubImage2D(gl.TEXTURE_2D, 0,\r\n\t\tx, y, w, h,\r\n\t\tgl.RGBA, gl.UNSIGNED_BYTE, array);\r\n}\r\n\r\n/**\r\n * @param gl\r\n * @param texture\r\n * @param x {number} in texels (4 words per texel)\r\n * @param y {number}\r\n * @param w {number} in texels\r\n * @param h {number}\r\n * @param array {Float32Array}\r\n */\r\nexport function writeToTextureFloat(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number, array: Float32Array) {\r\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\tgl.texSubImage2D(gl.TEXTURE_2D, 0,\r\n\t\tx, y, w, h,\r\n\t\tgl.RGBA, gl.FLOAT, array);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Other\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport function TEMP_MakeDualTriangle(array, stride) {\r\n\t// TODO Florian -- Replace with indexed vertices when possible\r\n\treturn [].concat.apply([], [\r\n\t\tarray.slice(0, stride),\r\n\t\tarray.slice(stride, 2 * stride),\r\n\t\tarray.slice(3 * stride, 4 * stride),\r\n\r\n\t\tarray.slice(0, 1 * stride),\r\n\t\tarray.slice(3 * stride, 4 * stride),\r\n\t\tarray.slice(2 * stride, 3 * stride)\r\n\t]);\r\n}\r\n","import {getScalingFactorOfMatrix, initShaderProgram, makeBuffer, makeRangeArray, TEMP_MakeDualTriangle} from \"./utils\";\r\nimport {\r\n\tdeclareReadPalette,\r\n\tdeclareReadTexel,\r\n\tenvColor,\r\n\tmakeOutputColor,\r\n\tPALETTE_HICOLOR_FLAG,\r\n\tPALETTE_TEX_H,\r\n\tPALETTE_TEX_W\r\n} from \"./shaders\";\r\nimport { DEBUG, VDP } from \"./vdp\";\r\n\r\n// How big (tall/wide) a sprite can be before it's broken down in smaller units of OBJ_CELL_SIZE^2\r\nconst OBJ_CELL_SIZE = 32;\r\n\r\nconst OBJ_BUFFER_STRIDE = 6;\r\n\r\n// TODO Florian -- Refactor to use zero-based indexes (and document) for all helper functions, like MapBuffer\r\nexport class ObjBuffer {\r\n\tname: string;\r\n\txyzp: Float32Array;\r\n\tuv: Float32Array;\r\n\tusedVertices: number = 0;\r\n\tmaxVertices: number;\r\n\r\n\t/**\r\n\t * @param name {string} for debugging\r\n\t * @param numVertices {number}\r\n\t */\r\n\tconstructor(name, numVertices) {\r\n\t\tthis.name = name;\r\n\t\tthis.xyzp = new Float32Array(numVertices * 4);\r\n\t\tthis.uv = new Float32Array(numVertices * 2);\r\n\t\tthis.maxVertices = numVertices;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of cells used.\r\n\t */\r\n\tcomputeUsedObjects(first: number = -1, count: number = -1): number {\r\n\t\tlet result = 0;\r\n\t\tif (first < 0) first = this.firstSprite;\r\n\t\tif (count < 0) count = this.usedSprites;\r\n\r\n\t\tfor (let i = first; i < first + count; i++) {\r\n\t\t\tresult += this.computeObjectCells(this.getSizeOfObject(i));\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tget firstSprite(): number {\r\n\t\treturn this.firstVertice / OBJ_BUFFER_STRIDE;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the first vertice to draw, which is also the last one inserted. In case you want to add a new component,\r\n\t * subtract from usedVertices (typically 4 or 6 for a quad) then set the buffers at the position of the firstVertice.\r\n\t * @returns {number} the index of the first vertice in the arrays (there are `usedVertices` then). Note that you'll\r\n\t * need to multiply by OBJ_BUFFER_STRIDE * <components per entry> to address the arrays.\r\n\t */\r\n\tget firstVertice(): number {\r\n\t\treturn \tthis.maxVertices - this.usedVertices;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {number} the z component of an object at the index-th position\r\n\t * @param index {number}\r\n\t */\r\n\tgetZOfObject(index): number {\r\n\t\treturn this.xyzp[OBJ_BUFFER_STRIDE * 4 * index + 2];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the size of an object at the index-th position.\r\n\t */\r\n\tgetSizeOfObject(objectIndex: number): {w: number, h: number} {\r\n\t\t// (left,top) in row 0.xy, (right,bottom) in row 2.xy\r\n\t\tconst vert = OBJ_BUFFER_STRIDE * 4 * objectIndex;\r\n\t\treturn {\r\n\t\t\tw: Math.abs(this.xyzp[vert + 4 * 2] - this.xyzp[vert]),\r\n\t\t\th: Math.abs(this.xyzp[vert + 4 * 2 + 1] - this.xyzp[vert + 1])\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Modifies the OBJ list to fit within the number of cells. Use the return value to know how many sprites to draw.\r\n\t * @param maxCells {number} maximum allowed number of cells\r\n\t * @returns {number} sprites fully drawable for this list\r\n\t */\r\n\tlimitObjList(maxCells: number): number {\r\n\t\tlet cells = 0;\r\n\t\tconst endOfList = this.firstSprite + this.usedSprites;\r\n\t\tfor (let i = this.firstSprite; i < endOfList; i++) {\r\n\t\t\tconst size = this.getSizeOfObject(i);\r\n\t\t\tconst current = this.computeObjectCells(size);\r\n\r\n\t\t\tif (cells + current > maxCells) {\r\n\r\n\t\t\t\t// TODO Florian -- Limit the width of this sprite -- Doesn't work because we need to scale the UV too with floating point UV rendering\r\n\t\t\t\t//const cellsTall = Math.ceil(size.h * layerTransform.scaling[1] / OBJ_CELL_SIZE);\r\n\t\t\t\t//const allowedCellsWide = (maxCells - cells) / cellsTall;\r\n\t\t\t\t//this.setWidthOfObject(i, allowedCellsWide * OBJ_CELL_SIZE);\r\n\t\t\t\t//return i - this.firstSprite + 1;\r\n\r\n\t\t\t\tif (DEBUG) console.log('Too many OBJ cells on ${this.name} (discarded ${endOfList - i}/${this.usedSprites} entries)');\r\n\t\t\t\treturn i - this.firstSprite;\r\n\t\t\t}\r\n\t\t\tcells += current;\r\n\t\t}\r\n\t\treturn this.usedSprites;\r\n\t}\r\n\r\n\t// Limit the width of an object (usually as a result of going outside of the sprite limit).\r\n\t// setWidthOfObject(objectIndex: number, width: number) {\r\n\t// \t// (left,top) in row 0.xy, (right,bottom) in row 2.xy\r\n\t// \tconst vert = OBJ_BUFFER_STRIDE * 4 * objectIndex;\r\n\t// \tthis.xyzp[vert + 4 * 2] = this.xyzp[vert] + width;\r\n\t// }\r\n\r\n\tsort(frontToBack = true) {\r\n\t\tconst items = makeRangeArray(this.firstVertice / OBJ_BUFFER_STRIDE, this.usedVertices / OBJ_BUFFER_STRIDE);\r\n\t\tif (frontToBack) {\r\n\t\t\t// First vertice, z component (3rd)\r\n\t\t\titems.sort((a, b) => this.getZOfObject(b) - this.getZOfObject(a));\r\n\t\t} else {\r\n\t\t\titems.sort((a, b) => this.getZOfObject(a) - this.getZOfObject(b));\r\n\t\t}\r\n\r\n\t\tconst originalXyzp = this.xyzp.slice();\r\n\t\tconst originalUv = this.uv.slice();\r\n\t\tfor (let i = 0; i < items.length; i++) {\r\n\t\t\tthis.xyzp.set(\r\n\t\t\t\toriginalXyzp.subarray(OBJ_BUFFER_STRIDE * 4 * items[i], OBJ_BUFFER_STRIDE * 4 * (items[i] + 1)),\r\n\t\t\t\tOBJ_BUFFER_STRIDE * 4 * i);\r\n\t\t\tthis.uv.set(\r\n\t\t\t\toriginalUv.subarray(OBJ_BUFFER_STRIDE * 2 * items[i], OBJ_BUFFER_STRIDE * 2 * (items[i] + 1)),\r\n\t\t\t\tOBJ_BUFFER_STRIDE * 2 * i);\r\n\t\t}\r\n\t}\r\n\r\n\tget usedSprites(): number {\r\n\t\treturn this.usedVertices / OBJ_BUFFER_STRIDE;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the number of pixels that an object uses with the transform. Note that even offscreen pixels count toward\r\n\t * the limit!\r\n\t */\r\n\tprivate computeObjectCells(size: {w: number, h: number}): number {\r\n\t\treturn Math.max(1, Math.ceil(size.w / OBJ_CELL_SIZE) * Math.ceil(size.h / OBJ_CELL_SIZE));\r\n\t}\r\n}\r\n\r\nexport function initObjShaders(vdp: VDP) {\r\n\tconst gl = vdp.gl;\r\n\t// Vertex shader program\r\n\tconst vsSource = `\r\n\t\t\t// The 3 first are the vertex position, the 4th is the palette ID\r\n\t\t\tattribute vec4 aXyzp;\r\n\t\t\t// The 2 first are the texture position\r\n\t\t\tattribute vec2 aUv;\r\n\t\r\n\t\t\tuniform mat3 uModelViewMatrix;\r\n\t\t\tuniform mat4 uProjectionMatrix;\r\n\t\r\n\t\t\tvarying highp vec2 vTextureCoord;\r\n\t\t\tvarying highp float vPaletteNo;\r\n\t\t\tuniform sampler2D uSamplerSprites, uSamplerPalettes;\r\n\t\t\r\n\t\t\tvoid main(void) {\r\n\t\t\t\t// Only scale the final matrix (we can always say that the VDP supports fixed point math inside for matrix multiplication)\r\n\t\t\t\tgl_Position = uProjectionMatrix * vec4(floor(uModelViewMatrix * vec3(aXyzp.xy, aXyzp.z)), 1);\r\n\t\t\t\tvPaletteNo = aXyzp.w;\r\n\t\t\t\tvTextureCoord = floor(aUv);\r\n\t\t\t}\r\n\t\t`;\r\n\tconst fsSource = `\r\n\t\t\tprecision highp float;\r\n\t\t\t\r\n\t\t\tvarying highp vec2 vTextureCoord;\r\n\t\t\tvarying highp float vPaletteNo;\r\n\t\t\tuniform vec4 uEnvColor;\r\n\t\t\tuniform sampler2D uSamplerSprites, uSamplerPalettes;\r\n\t\r\n\t\t\t${declareReadTexel()}\r\n\t\t\t${declareReadPalette()}\r\n\t\t\r\n\t\t\tvoid main(void) {\r\n\t\t\t\tfloat texel, palette;\r\n\t\t\t\tif (vPaletteNo >= ${PALETTE_HICOLOR_FLAG}.0) {\r\n\t\t\t\t\ttexel = readTexel8(vTextureCoord.x, vTextureCoord.y);\r\n\t\t\t\t\tpalette = (vPaletteNo - ${PALETTE_HICOLOR_FLAG}.0) / ${PALETTE_TEX_H}.0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttexel = readTexel4(vTextureCoord.x, vTextureCoord.y);\r\n\t\t\t\t\tpalette = vPaletteNo / ${PALETTE_TEX_H}.0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Color zero\r\n\t\t\t\tif (texel < ${1.0 / (PALETTE_TEX_W)}) discard;\r\n\r\n\t\t\t\tvec4 color = readPalette(texel, palette);\r\n\t\t\t\tgl_FragColor = ${makeOutputColor('color')};\r\n\t\t\t}\r\n\t\t`;\r\n\r\n\t// TODO Florian -- Use indexed VAOs\r\n\tconst shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n\tvdp.spriteProgram = {\r\n\t\tprogram: shaderProgram,\r\n\t\tattribLocations: {\r\n\t\t\txyzp: gl.getAttribLocation(shaderProgram, 'aXyzp'),\r\n\t\t\tuv: gl.getAttribLocation(shaderProgram, 'aUv'),\r\n\t\t},\r\n\t\tglBuffers: {\r\n\t\t\txyzp: makeBuffer(gl),\r\n\t\t\tuv: makeBuffer(gl)\r\n\t\t},\r\n\t\tuniformLocations: {\r\n\t\t\tenvColor: gl.getUniformLocation(shaderProgram, 'uEnvColor'),\r\n\t\t\tprojectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n\t\t\tmodelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n\t\t\tuSamplerSprites: gl.getUniformLocation(shaderProgram, 'uSamplerSprites'),\r\n\t\t\tuSamplerPalettes: gl.getUniformLocation(shaderProgram, 'uSamplerPalettes'),\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * @param vdp {VDP}\r\n * @param objBuffer {ObjBuffer}\r\n * @param objLimit {number} max number of cells drawable\r\n */\r\nexport function drawPendingObj(vdp: VDP, objBuffer: ObjBuffer, objLimit: number = 0) {\r\n\tlet numObjectsToDraw = objBuffer.usedSprites;\r\n\tif (objLimit > 0) numObjectsToDraw = objBuffer.limitObjList(objLimit);\r\n\tif (numObjectsToDraw <= 0) return;\r\n\r\n\tconst prog = vdp.spriteProgram;\r\n\tconst gl = vdp.gl;\r\n\r\n\tconst firstVertice = objBuffer.firstVertice;\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, objBuffer.xyzp.subarray(firstVertice * 4), gl.STREAM_DRAW);\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.uv);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, objBuffer.uv.subarray(firstVertice * 2), gl.STREAM_DRAW);\r\n\r\n\tgl.useProgram(prog.program);\r\n\t{\r\n\t\tconst numComponents = 4;  // pull out 4 values per iteration\r\n\t\tconst type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n\t\tconst normalize = false;  // don't normalize\r\n\t\tconst stride = 0;         // how many bytes to get from one set of values to the next\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 0 = use type and numComponents above\r\n\t\tconst offset = 0;         // how many bytes inside the buffer to start from\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.xyzp, numComponents, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.xyzp);\r\n\t}\r\n\t{\r\n\t\tconst num = 2, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.uv);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.uv, num, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.uv);\r\n\t}\r\n\r\n\t// Tell WebGL we want to affect texture unit 0\r\n\tgl.activeTexture(gl.TEXTURE0);\r\n\t// Bind the texture to texture unit 0\r\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.spriteTexture);\r\n\tgl.activeTexture(gl.TEXTURE1);\r\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.paletteTexture);\r\n\r\n\t// Tell the shader we bound the texture to texture unit 0\r\n\tgl.uniform1i(prog.uniformLocations.uSamplerSprites, 0);\r\n\tgl.uniform1i(prog.uniformLocations.uSamplerPalettes, 1);\r\n\r\n\t// Set the shader uniforms\r\n\tgl.uniformMatrix4fv(prog.uniformLocations.projectionMatrix, false, vdp.projectionMatrix);\r\n\tgl.uniformMatrix3fv(prog.uniformLocations.modelViewMatrix,false, vdp.modelViewMatrix);\r\n\r\n\tgl.uniform4f(prog.uniformLocations.envColor, envColor[0], envColor[1], envColor[2], envColor[3]);\r\n\r\n\tgl.drawArrays(gl.TRIANGLES, 0, numObjectsToDraw * OBJ_BUFFER_STRIDE);\r\n\r\n\tobjBuffer.usedVertices = 0;\r\n}\r\n\r\nexport function enqueueObj(objBuffer: ObjBuffer, xStart: number, yStart: number, xEnd: number, yEnd: number, uStart: number, vStart: number, uEnd: number, vEnd: number, palNo: number, hiColor: boolean, z: number = 0) {\r\n\tif (hiColor) palNo |= PALETTE_HICOLOR_FLAG;\r\n\r\n\tif (objBuffer.usedVertices >= objBuffer.maxVertices) {\r\n\t\tif (DEBUG) console.log(`${objBuffer.name} overuse (max ${objBuffer.maxVertices / OBJ_BUFFER_STRIDE}), ignoring drawOBJ`);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Start from the end\r\n\tobjBuffer.usedVertices += OBJ_BUFFER_STRIDE;\r\n\tconst firstVertice = objBuffer.firstVertice;\r\n\r\n\tobjBuffer.xyzp.set(TEMP_MakeDualTriangle([\r\n\t\txStart, yStart, z, palNo,\r\n\t\txEnd, yStart, z, palNo,\r\n\t\txStart, yEnd, z, palNo,\r\n\t\txEnd, yEnd, z, palNo,\r\n\t], 4), 4 * firstVertice);\r\n\r\n\tobjBuffer.uv.set(TEMP_MakeDualTriangle([\r\n\t\tuStart, vStart,\r\n\t\tuEnd, vStart,\r\n\t\tuStart, vEnd,\r\n\t\tuEnd, vEnd,\r\n\t], 2), 2 * firstVertice);\r\n\r\n}\r\n\r\nexport function makeObjBuffer(name: string, numSprites: number): ObjBuffer {\r\n\treturn new ObjBuffer(name, numSprites * OBJ_BUFFER_STRIDE);\r\n}\r\n","import {initShaderProgram, makeBuffer, TEMP_MakeDualTriangle} from \"./utils\";\r\nimport {\r\n\tdeclareReadPalette,\r\n\tdeclareReadTexel,\r\n\tenvColor,\r\n\tmakeOutputColor,\r\n\tMAP_TEX_H,\r\n\tMAP_TEX_W,\r\n\tOTHER_TEX_H,\r\n\tOTHER_TEX_W,\r\n\tPALETTE_HICOLOR_FLAG,\r\n\tPALETTE_TEX_H,\r\n\tPALETTE_TEX_W\r\n} from \"./shaders\";\r\nimport { DEBUG, VDP } from \"./vdp\";\r\n\r\nconst BG_BUFFER_STRIDE = 6;\r\n\r\nexport class MapBuffer {\r\n\tname: string;\r\n\txyzp: Float32Array;\r\n\tmapInfo1: Float32Array;\r\n\tmapInfo2: Float32Array;\r\n\tmapInfo3: Float32Array;\r\n\tmapInfo4: Float32Array;\r\n\tusedVertices: number = 0;\r\n\tmaxVertices: number;\r\n\r\n\tconstructor(name: string, numVertices: number) {\r\n\t\tthis.name = name;\r\n\t\tthis.xyzp = new Float32Array(numVertices * 4);\r\n\t\tthis.mapInfo1 = new Float32Array(numVertices * 4);\r\n\t\tthis.mapInfo2 = new Float32Array(numVertices * 4);\r\n\t\tthis.mapInfo3 = new Float32Array(numVertices * 4);\r\n\t\tthis.mapInfo4 = new Float32Array(numVertices * 4);\r\n\t\tthis.maxVertices = numVertices;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {number} the index of the first vertice in the arrays (there are `usedVertices` then). Note that you'll\r\n\t * need to multiply by OBJ_BUFFER_STRIDE * <components per entry> to address the arrays.\r\n\t */\r\n\tget firstVertice(): number {\r\n\t\treturn \tthis.maxVertices - this.usedVertices;\r\n\t}\r\n\r\n\tget usedLayers(): number {\r\n\t\treturn this.usedVertices / BG_BUFFER_STRIDE;\r\n\t}\r\n}\r\n\r\nexport function initMapShaders(vdp: VDP) {\r\n\tconst gl = vdp.gl;\r\n\t// Vertex shader program\r\n\tconst vsSource = `\r\n\t\t\tattribute vec4 aXyzp;\r\n\t\t\tattribute vec4 aMapInfo1;\r\n\t\t\tattribute vec4 aMapInfo2;\r\n\t\t\tattribute vec4 aMapInfo3;\r\n\t\t\tattribute vec4 aMapInfo4;\r\n\t\t\tuniform mat3 uModelViewMatrix;\r\n\t\t\tuniform mat4 uProjectionMatrix;\r\n\r\n\t\t\tvarying vec2 vTextureCoord;\r\n\t\t\tvarying float vPaletteNo;\r\n\t\t\t// TODO Florian -- use vec4 and extract in fragment program\r\n\t\t\tvarying highp vec2 vMapStart;\r\n\t\t\tvarying highp vec2 vMapSize;\r\n\t\t\tvarying vec2 vTilesetStart;\r\n\t\t\tvarying float vTilesetWidth;\r\n\t\t\tvarying vec2 vTileSize;\r\n\t\t\tvarying mat3 vTransformationMatrix;\r\n\t\t\t// [0] = linescroll buffer, if 0 use vTransformationMatrix always, [1] = whether to wrap around\r\n\t\t\tvarying vec2 vOtherInfo;\r\n\t\t\t\r\n\t\t\tuniform sampler2D uSamplerMaps, uSamplerSprites, uSamplerPalettes, uSamplerOthers;\r\n\t\t\r\n\t\t\tmat3 readLinescrollBuffer(int bufferNo, int horizOffset) {\r\n\t\t\t\tfloat vOfs = float(bufferNo) / ${OTHER_TEX_H}.0;\r\n\t\t\t\tvec4 first = texture2D(uSamplerOthers, vec2(float(horizOffset) / ${OTHER_TEX_W}.0, vOfs));\r\n\t\t\t\tvec4 second = texture2D(uSamplerOthers, vec2(float(horizOffset + 1) / ${OTHER_TEX_W}.0, vOfs));\r\n\t\t\t\treturn mat3(\r\n\t\t\t\t\tfirst.xy, 0,\r\n\t\t\t\t\tvec2(first.a, second.r), 0,\r\n\t\t\t\t\tsecond.ba, 1.0);\r\n\t\t\t}\r\n\t\t\r\n\t\t\tvoid main(void) {\r\n\t\t\t\t// Only scale the final matrix (we can always say that the VDP supports fixed point math inside for matrix multiplication)\r\n\t\t\t\tgl_Position = uProjectionMatrix * vec4(floor(uModelViewMatrix * aXyzp.xyz), 1);\r\n\t\t\t\tvPaletteNo = floor(aXyzp.w);\r\n\t\t\t\tvMapStart = floor(aMapInfo1.xy);\r\n\t\t\t\tvTilesetStart = floor(aMapInfo1.zw);\r\n\t\t\t\tvMapSize = floor(aMapInfo2.xy);\r\n\t\t\t\tvTilesetWidth = floor(aMapInfo2.z);\r\n\t\t\t\tvTileSize = floor(aMapInfo3.xy);\r\n\t\t\t\tvTextureCoord = floor(aMapInfo3.zw);\r\n\t\t\t\tvOtherInfo = floor(aMapInfo4.xy);\r\n\t\t\t\t// If 0-255, use one transformation map-wide from the first line, if -1 never use transformations\r\n\t\t\t\tif (aMapInfo4.x >= 0.0 && aMapInfo4.x < 256.0) {\r\n\t\t\t\t\tvTransformationMatrix = readLinescrollBuffer(0, int(aMapInfo4.x) * 2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvTransformationMatrix = mat3(\r\n\t\t\t\t\t\t1, 0, 0,\r\n\t\t\t\t\t\t0, 1, 0,\r\n\t\t\t\t\t\t0, 0, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t`;\r\n\tconst fsSource = `\r\n\t\t\tprecision highp float;\r\n\t\t\t\r\n\t\t\tvarying highp vec2 vTextureCoord;\r\n\t\t\tvarying highp float vPaletteNo;\r\n\t\t\tvarying highp vec2 vMapStart;\r\n\t\t\tvarying highp vec2 vMapSize;\r\n\t\t\t// tilesetSize is in tiles!\r\n\t\t\tvarying vec2 vTilesetStart;\r\n\t\t\tvarying float vTilesetWidth;\r\n\t\t\tvarying vec2 vTileSize;\r\n\t\t\tvarying mat3 vTransformationMatrix;\r\n\t\t\tvarying vec2 vOtherInfo;\r\n\t\t\t\r\n\t\t\tuniform mat3 uModelViewMatrix;\r\n\t\t\tuniform vec4 uEnvColor;\r\n\t\t\tuniform sampler2D uSamplerMaps, uSamplerSprites, uSamplerPalettes, uSamplerOthers;\r\n\t\t\t\t\t\t\r\n\t\t\tint intDiv(float x, float y) {\r\n\t\t\t\treturn int(floor(x / y));\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns accurate MOD when arguments are approximate integers.\r\n\t\t\t * https://stackoverflow.com/questions/33908644/get-accurate-integer-modulo-in-webgl-shader\r\n\t\t\t */\r\n\t\t\tfloat modI(float a,float b) {\r\n\t\t\t\tfloat m=a-floor((a+0.5)/b)*b;\r\n\t\t\t\treturn floor(m+0.5);\r\n\t\t\t}\r\n\r\n\t\t\tmat3 readLinescrollBuffer(int bufferNo, int horizOffset) {\r\n\t\t\t\tfloat vOfs = float(bufferNo) / ${OTHER_TEX_H}.0;\r\n\t\t\t\tvec4 first = texture2D(uSamplerOthers, vec2(float(horizOffset) / ${OTHER_TEX_W}.0, vOfs));\r\n\t\t\t\tvec4 second = texture2D(uSamplerOthers, vec2(float(horizOffset + 1) / ${OTHER_TEX_W}.0, vOfs));\r\n\t\t\t\treturn mat3(\r\n\t\t\t\t\tfirst.r, first.g, 0,\r\n\t\t\t\t\tfirst.a, second.r, 0,\r\n\t\t\t\t\tsecond.b, second.a, 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tint readMap(int x, int y) {\r\n\t\t\t\tx = int(modI(float(x), vMapSize.x) + vMapStart.x);\r\n\t\t\t\ty = int(modI(float(y), vMapSize.y) + vMapStart.y);\r\n\t\t\t\t\r\n\t\t\t\tint texelId = x / 2;\r\n\t\t\t\tint texelC = x - texelId * 2;\r\n\t\t\t\tvec4 read = texture2D(uSamplerMaps, vec2(float(texelId) / ${MAP_TEX_W}.0, float(y) / ${MAP_TEX_H}.0));\r\n\t\t\t\tif (texelC == 0) return int(read.r * 255.0) + int(read.g * 255.0) * 256;\r\n\t\t\t\treturn int(read.b * 255.0) + int(read.a * 255.0) * 256;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec2 positionInTexture(int tileNo) {\r\n\t\t\t\tvec2 base = vTilesetStart;\r\n\t\t\t\tfloat rowNo = float(tileNo / int(vTilesetWidth));\r\n\t\t\t\tfloat colNo = modI(float(tileNo), vTilesetWidth);\r\n\t\t\t\treturn base + vec2(colNo * vTileSize.x, rowNo * vTileSize.y);\r\n\t\t\t}\r\n\t\t\r\n\t\t\t${declareReadTexel()}\r\n\t\t\t${declareReadPalette()}\r\n\t\t\r\n\t\t\tvoid main(void) {\r\n\t\t\t\tmat3 transformationMatrix;\r\n\t\t\t\tfloat y = vTextureCoord.y;\r\n\t\t\t\t// Per-line info\r\n\t\t\t\tif (vOtherInfo.x >= 256.0) {\r\n\t\t\t\t\t// 2 colors (8 float values) per matrix\r\n\t\t\t\t\ttransformationMatrix = readLinescrollBuffer(int(vOtherInfo.x) - 256, int(y) * 2);\r\n\t\t\t\t\ty = 0.0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttransformationMatrix = vTransformationMatrix;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvec2 texCoord = floor((transformationMatrix * vec3(vTextureCoord.x, y, 1)).xy);\r\n\t\t\t\tint mapX = intDiv(texCoord.x, vTileSize.x), mapY = intDiv(texCoord.y, vTileSize.y);\r\n\t\t\t\t\r\n\t\t\t\t// Out of bounds?\r\n\t\t\t\tif (vOtherInfo.y < 1.0 && (mapX < 0 || mapY < 0 || mapX >= int(vMapSize.x) || mapY >= int(vMapSize.y))) {\r\n\t\t\t\t\tdiscard;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tint mapTileNo = readMap(mapX, mapY);\r\n\t\t\t\t// Invisible tile (TODO Florian -- support in the converter)\r\n\t\t\t\tif (mapTileNo >= 65535) discard;\r\n\r\n\t\t\t\t// Bits 12-15: palette No\r\n\t\t\t\tint palOfs = mapTileNo / ${1 << 12};\r\n\t\t\t\tfloat paletteOffset = float(palOfs);\r\n\t\t\t\tmapTileNo -= palOfs * ${1 << 12};\r\n\r\n\t\t\t\t// Position of tile no in sprite texture, now we need to add the offset\r\n\t\t\t\tvec2 offsetInTile = vec2(int(texCoord.x) - mapX * int(vTileSize.x), int(texCoord.y) - mapY * int(vTileSize.y));\r\n\t\t\t\tvec2 tilesetPos = positionInTexture(mapTileNo) + offsetInTile;\r\n\t\t\t\tfloat texel;\r\n\r\n\t\t\t\tif (vPaletteNo >= ${PALETTE_HICOLOR_FLAG}.0) {\r\n\t\t\t\t\ttexel = readTexel8(tilesetPos.x, tilesetPos.y);\r\n\t\t\t\t\tpaletteOffset += (vPaletteNo - ${PALETTE_HICOLOR_FLAG}.0);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttexel = readTexel4(tilesetPos.x, tilesetPos.y);\r\n\t\t\t\t\tpaletteOffset += vPaletteNo;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if (vTextureCoord.x < 16.0) {\r\n\t\t\t\t// \tvec4 color = vec4(0, 0, 0, 1);\r\n\t\t\t\t// \t// float ym = mod(float(mapY), vMapSize.y) + vMapStart.y;\r\n\t\t\t\t// \t// color.b = (float(mapY) - ( float(mapY / int(vMapSize.y))) / 2.0;\r\n\t\t\t\t// \tint times = intDiv(float(mapY), vMapSize.y - 0.001);\r\n\t\t\t\t// \tcolor.g = modI(float(mapY), vMapSize.y) / 2.0;\r\n\t\t\t\t// \tcolor.b = float(mapY) / 28.0;\r\n\t\t\t\t// \tgl_FragColor = color;\r\n\t\t\t\t// }\r\n\t\t\t\t// else {\r\n\t\t\t\t\t// Color zero\r\n\t\t\t\t\tif (texel < ${1.0 / PALETTE_TEX_W}) discard;\r\n\t\t\t\t\r\n\t\t\t\t\tvec4 color = readPalette(texel, paletteOffset / ${PALETTE_TEX_H}.0);\r\n\t\t\t\t\tgl_FragColor = ${makeOutputColor('color')};\r\n\t\t\t\t// }\r\n\t\t\t}\r\n\t\t`;\r\n\r\n\tconst shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\tvdp.mapProgram = {\r\n\t\tprogram: shaderProgram,\r\n\t\tattribLocations: {\r\n\t\t\txyzp: gl.getAttribLocation(shaderProgram, 'aXyzp'),\r\n\t\t\tmapInfo1: gl.getAttribLocation(shaderProgram, 'aMapInfo1'),\r\n\t\t\tmapInfo2: gl.getAttribLocation(shaderProgram, 'aMapInfo2'),\r\n\t\t\tmapInfo3: gl.getAttribLocation(shaderProgram, 'aMapInfo3'),\r\n\t\t\tmapInfo4: gl.getAttribLocation(shaderProgram, 'aMapInfo4')\r\n\t\t},\r\n\t\tglBuffers: {\r\n\t\t\txyzp: makeBuffer(gl),\r\n\t\t\tmapInfo1: makeBuffer(gl),\r\n\t\t\tmapInfo2: makeBuffer(gl),\r\n\t\t\tmapInfo3: makeBuffer(gl),\r\n\t\t\tmapInfo4: makeBuffer(gl)\r\n\t\t},\r\n\t\tuniformLocations: {\r\n\t\t\tenvColor: gl.getUniformLocation(shaderProgram, 'uEnvColor'),\r\n\t\t\tprojectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n\t\t\tmodelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),\r\n\t\t\tuSamplerMaps: gl.getUniformLocation(shaderProgram, 'uSamplerMaps'),\r\n\t\t\tuSamplerSprites: gl.getUniformLocation(shaderProgram, 'uSamplerSprites'),\r\n\t\t\tuSamplerPalettes: gl.getUniformLocation(shaderProgram, 'uSamplerPalettes'),\r\n\t\t\tuSamplerOthers: gl.getUniformLocation(shaderProgram, 'uSamplerOthers'),\r\n\t\t},\r\n\t};\r\n}\r\n\r\nexport function drawPendingMap(vdp: VDP, mapBuffer: MapBuffer) {\r\n\tif (mapBuffer.usedVertices < 3) return;\r\n\r\n\tconst gl = vdp.gl;\r\n\tconst prog = vdp.mapProgram;\r\n\tconst firstVertice = mapBuffer.firstVertice;\r\n\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.xyzp.subarray(firstVertice * 4), gl.STREAM_DRAW);\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo1);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo1.subarray(firstVertice * 4), gl.STREAM_DRAW);\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo2);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo2.subarray(firstVertice * 4), gl.STREAM_DRAW);\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo3);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo3.subarray(firstVertice * 4), gl.STREAM_DRAW);\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo4);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, mapBuffer.mapInfo4.subarray(firstVertice * 4), gl.STREAM_DRAW);\r\n\r\n\tgl.useProgram(prog.program);\r\n\t{\r\n\t\tconst numComponents = 4;  // pull out 4 values per iteration\r\n\t\tconst type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n\t\tconst normalize = false;  // don't normalize\r\n\t\tconst stride = 0;         // how many bytes to get from one set of values to the next\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 0 = use type and numComponents above\r\n\t\tconst offset = 0;         // how many bytes inside the buffer to start from\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xyzp);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.xyzp, numComponents, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.xyzp);\r\n\t}\r\n\t{\r\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo1);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo1, num, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo1);\r\n\t}\r\n\t{\r\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo2);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo2, num, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo2);\r\n\t}\r\n\t{\r\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo3);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo3, num, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo3);\r\n\t}\r\n\t{\r\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.mapInfo4);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.mapInfo4, num, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.mapInfo4);\r\n\t}\r\n\r\n\t// Tell WebGL we want to affect texture unit 0\r\n\tgl.activeTexture(gl.TEXTURE0);\r\n\t// Bind the texture to texture unit 0\r\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.spriteTexture);\r\n\tgl.activeTexture(gl.TEXTURE1);\r\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.paletteTexture);\r\n\tgl.activeTexture(gl.TEXTURE2);\r\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.mapTexture);\r\n\tgl.activeTexture(gl.TEXTURE3);\r\n\tgl.bindTexture(gl.TEXTURE_2D, vdp.otherTexture);\r\n\r\n\t// Tell the shader we bound the texture to texture unit 0\r\n\tgl.uniform1i(prog.uniformLocations.uSamplerSprites, 0);\r\n\tgl.uniform1i(prog.uniformLocations.uSamplerPalettes, 1);\r\n\tgl.uniform1i(prog.uniformLocations.uSamplerMaps, 2);\r\n\tgl.uniform1i(prog.uniformLocations.uSamplerOthers, 3);\r\n\r\n\t// Set the shader uniforms\r\n\tgl.uniformMatrix4fv(prog.uniformLocations.projectionMatrix, false, vdp.projectionMatrix);\r\n\tgl.uniformMatrix3fv(prog.uniformLocations.modelViewMatrix,false, vdp.modelViewMatrix);\r\n\r\n\tgl.uniform4f(prog.uniformLocations.envColor, envColor[0], envColor[1], envColor[2], envColor[3]);\r\n\r\n\tgl.drawArrays(gl.TRIANGLES, 0, mapBuffer.usedVertices);\r\n\r\n\tmapBuffer.usedVertices = 0;\r\n}\r\n\r\nexport function enqueueMap(mapBuffer: MapBuffer, uMap: number, vMap: number, uTileset: number, vTileset: number, mapWidth: number, mapHeight: number, tilesetWidth: number, tileWidth: number, tileHeight: number, winX: number, winY: number, winW: number, winH: number, scrollX: number, scrollY: number, palNo: number, hiColor: boolean, linescrollBuffer: number = -1, wrap: number = 1, z: number = 0) {\r\n\r\n\t// Remove the + win* to start the map at the window instead of continuing it\r\n\tscrollX += winX;\r\n\tscrollY += winY;\r\n\r\n\ttilesetWidth = Math.floor(tilesetWidth / tileWidth);\r\n\tif (hiColor) palNo |= PALETTE_HICOLOR_FLAG;\r\n\r\n\tif (mapBuffer.usedVertices >= mapBuffer.maxVertices) {\r\n\t\tif (DEBUG) console.log(`${mapBuffer.name} overuse (max ${mapBuffer.maxVertices / BG_BUFFER_STRIDE}), ignoring drawBG`);\r\n\t\treturn;\r\n\t}\r\n\tmapBuffer.usedVertices += BG_BUFFER_STRIDE;\r\n\tconst firstVertice = mapBuffer.firstVertice;\r\n\r\n\t// x, y position, z for normal-prio tiles, base palette no\r\n\tmapBuffer.xyzp.set(TEMP_MakeDualTriangle([\r\n\t\twinX, winY, z, palNo,\r\n\t\twinX + winW, winY, z, palNo,\r\n\t\twinX, winY + winH, z, palNo,\r\n\t\twinX + winW, winY + winH, z, palNo,\r\n\t], 4), 4 * firstVertice);\r\n\t// u, v map base, u, v tileset base\r\n\tmapBuffer.mapInfo1.set(TEMP_MakeDualTriangle([\r\n\t\tuMap, vMap, uTileset, vTileset,\r\n\t\tuMap, vMap, uTileset, vTileset,\r\n\t\tuMap, vMap, uTileset, vTileset,\r\n\t\tuMap, vMap, uTileset, vTileset\r\n\t], 4), 4 * firstVertice);\r\n\t// map width, map height, tileset width, z for hi-prio tiles\r\n\tmapBuffer.mapInfo2.set(TEMP_MakeDualTriangle([\r\n\t\tmapWidth, mapHeight, tilesetWidth, 0,\r\n\t\tmapWidth, mapHeight, tilesetWidth, 0,\r\n\t\tmapWidth, mapHeight, tilesetWidth, 0,\r\n\t\tmapWidth, mapHeight, tilesetWidth, 0\r\n\t], 4), 4 * firstVertice);\r\n\t// tile width, tile height, drawing uv\r\n\tmapBuffer.mapInfo3.set(TEMP_MakeDualTriangle([\r\n\t\ttileWidth, tileHeight, scrollX, scrollY,\r\n\t\ttileWidth, tileHeight, scrollX + winW, scrollY,\r\n\t\ttileWidth, tileHeight, scrollX, scrollY + winH,\r\n\t\ttileWidth, tileHeight, scrollX + winW, scrollY + winH\r\n\t], 4), 4 * firstVertice);\r\n\t// linescroll buffer (row no in otherTexture), whether to wrap around map size (0=off, 1=on)\r\n\tmapBuffer.mapInfo4.set(TEMP_MakeDualTriangle([\r\n\t\tlinescrollBuffer, wrap, 0, 0,\r\n\t\tlinescrollBuffer, wrap, 0, 0,\r\n\t\tlinescrollBuffer, wrap, 0, 0,\r\n\t\tlinescrollBuffer, wrap, 0, 0\r\n\t], 4), 4 * firstVertice);\r\n}\r\n\r\n/**\r\n * @param name {string} for debugging\r\n * @param numMaps {number} number of maps that may be contained (batched) inside the map buffer.\r\n * @returns {MapBuffer}\r\n */\r\nexport function makeMapBuffer(name: string, numMaps: number): MapBuffer {\r\n\treturn new MapBuffer(name, numMaps * BG_BUFFER_STRIDE);\r\n}\r\n","export class VdpMap {\r\n\tx: number; // U position in the map texture (cells)\r\n\ty: number; // V position in the map texture (cells)\r\n\tw: number; // width of sprite (pixels)\r\n\th: number; // height of sprite (pixels)\r\n\tdesignTileset: string; // name of the tileset (VdpSprite)\r\n\tdesignPalette: string; // name of the first palette (takes precedence over the one defined in the tileset); tiles can use this and the next 15 palettes via the bits 12-15 in the tile number.\r\n\r\n\tconstructor(x: number, y: number, w: number, h: number, designTileset: string, designPalette: string) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.w = w;\r\n\t\tthis.h = h;\r\n\t\tthis.designTileset = designTileset;\r\n\t\tthis.designPalette = designPalette;\r\n\t}\r\n\r\n\toffsetted(x: number, y: number, w: number, h: number): VdpMap {\r\n\t\tthis.x += x;\r\n\t\tthis.y += y;\r\n\t\tthis.w = w;\r\n\t\tthis.h = h;\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nexport class VdpPalette {\r\n\ty: number; // V position of palette (color units)\r\n\tw: number; // count (color units)\r\n\th: number; // number of rows (consecutive palettes)\r\n\r\n\tconstructor(y: number, w: number, h: number) {\r\n\t\tthis.y = y;\r\n\t\tthis.w = w;\r\n\t\tthis.h = h;\r\n\t}\r\n\r\n\toffsetted(y: number, w: number, h: number): VdpPalette {\r\n\t\tthis.y += y;\r\n\t\tthis.w = w;\r\n\t\tthis.h = h;\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nexport class VdpSprite {\r\n\tx: number; // U position in the sprite texture (pixels)\r\n\ty: number; // V position in the sprite texture (pixels)\r\n\tw: number; // width of sprite or tileset as a whole (pixels)\r\n\th: number; // height of sprite or tileset as a whole (pixels)\r\n\ttw: number; // tile width (pixels) if it's a tileset\r\n\tth: number; // tile height (pixels) if it's a tileset\r\n\ttiles: number; // number of (used) tiles in the tileset\r\n\thiColor: boolean; // whether it's a 8-bit-per-pixel tile (or 4-bit)\r\n\tdesignPalette: string; // design palette name (can be overriden)\r\n\r\n\tconstructor(x: number, y: number, w: number, h: number, tw: number, th: number, tiles: number, hiColor: boolean, designPalette: string) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.w = w;\r\n\t\tthis.h = h;\r\n\t\tthis.tw = tw;\r\n\t\tthis.th = th;\r\n\t\tthis.tiles = tiles;\r\n\t\tthis.hiColor = hiColor;\r\n\t\tthis.designPalette = designPalette;\r\n\t}\r\n\r\n\toffsetted(x: number, y: number, w: number, h: number): VdpSprite {\r\n\t\tthis.x += x;\r\n\t\tthis.y += y;\r\n\t\tthis.w = w;\r\n\t\tthis.h = h;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Modifies this instance of VdpSprite (not the original) to target a given tile in a tileset.\r\n\t * @throws {Error} if this sprite is not a tileset.\r\n\t * @param no tile number to target.\r\n\t * @returns {VdpSprite} this\r\n\t */\r\n\ttile(no: number): VdpSprite {\r\n\t\tconst columnsPerRow = Math.floor(this.w / this.tw);\r\n\t\tif (this.w / this.tw !== columnsPerRow) {\r\n\t\t\tthrow new Error(`Not a tileset (w=${this.w}, h=${this.h}, tw=${this.tw})`)\r\n\t\t}\r\n\r\n\t\tconst col = no % columnsPerRow;\r\n\t\tconst row = Math.floor(no / columnsPerRow);\r\n\t\treturn this.offsetted(col * this.tw, row * this.th, this.tw, this.th);\r\n\t}\r\n}\r\n\r\n/**\r\n * Used to represent data read from (or written to) memory.\r\n *\r\n * In the VDP16, memory is always addressed in 2D. It has the advantage of being easier to represent for users and be\r\n * much more flexible. However, underlying memory is still exposed as a one-dimensional array in the end, containing\r\n * [height] lines of [width] integers, each of which represents a pixel, a map element or a palette color. Therefore,\r\n * accessing to the buffer element (x, y) is done as such: Array2D.buffer[x + y * width]. Since it's heavily used all\r\n * around, we created this class to wrap up the data buffer and the width of each column.\r\n *\r\n * For reference, sprites use 8 bit data (Uint8Array), each element being one or two pixels depending on the hi-color\r\n * mode. Map elements use 16 bit data (Uint16Array), each element being a map element. Palettes use 32 bit data\r\n * (Uint32Array), each element representing a color in RGBA format (write 0xaabbggrr with r=8 red bits, g=green, b=blue\r\n * and a=alpha, ignored unless you use the alpha-based blending modes).\r\n */\r\nexport class Array2D {\r\n\tbuffer: Uint8Array|Uint16Array|Uint32Array;\r\n\twidth: number;\r\n\theight: number;\r\n\r\n\tconstructor(buffer: Uint8Array|Uint16Array|Uint32Array, width: number, height: number) {\r\n\t\tthis.buffer = buffer;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t}\r\n\r\n\tgetElement(x: number, y: number): number {\r\n\t\treturn this.buffer[this.width * y + x];\r\n\t}\r\n\r\n\tsetElement(x: number, y: number, value: number) {\r\n\t\tthis.buffer[this.width * y + x] = value;\r\n\t}\r\n}\r\n\r\n/**\r\n * Fills the memory with a given value.\r\n */\r\nexport function memset(buffer: Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array, value: number, numEntries: number) {\r\n\tbuffer.fill(value, 0, numEntries);\r\n}\r\n\r\nexport function memcpy(dst: Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array, src: Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array) {\r\n\tdst.set(src);\r\n}\r\n","\r\nexport class color32 {\r\n\t/**\r\n\t * @param c color (32 bits)\r\n\t * @param [bitsPerComponent=8] {number} can be 2, 3, 4, 5 to return a reduced color value (x bits per component)\r\n\t * @returns {{r: number, g: number, b: number, a: number}}\r\n\t */\r\n\tstatic extract(c: number, bitsPerComponent: number = 8): { a: number; b: number; r: number; g: number } {\r\n\t\tc = color32.posterize(c, bitsPerComponent);\r\n\t\treturn {\r\n\t\t\ta: c >>> 24,\r\n\t\t\tb: c >>> 16 & 0xff,\r\n\t\t\tg: c >>> 8 & 0xff,\r\n\t\t\tr: c & 0xff,\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Use make( { r: , g: , } ) or make(r, g, b).\r\n\t * @param r {number|{r: number, g: number, b: number, a: number}} red component (0 to 255) or color as extracted with\r\n\t * color32.extract().\r\n\t * @param [g] {number} green component (0 to 255)\r\n\t * @param [b] {number} blue component (0 to 255)\r\n\t * @param [a=255] {number} alpha component (not used, only required to make a valid color for your display adapter)\r\n\t * @returns {number} resulting color\r\n\t */\r\n\tstatic make(r: number|{r: number, g: number, b: number, a: number}, g: number = 0, b: number = 0, a: number = 0xff): number {\r\n\t\tif (typeof r === 'number') return r | g << 8 | b << 16 | a << 24;\r\n\t\treturn r.r | r.g << 8 | r.b << 16 | r.a << 24;\r\n\t}\r\n\r\n\t/**\r\n\t * Extends a 16 bit RGBA color into a 32 bit RGBA color. Note that 0xRGBA will produce 0xAABBGGRR, reversing the byte\r\n\t * order as OpenGL expects it.\r\n\t * @param col {number}\r\n\t * @returns {number}\r\n\t */\r\n\tstatic extendColor12(col: number): number {\r\n\t\treturn color32.reverseColor32((col & 0xf) | (col & 0xf) << 4 |\r\n\t\t\t(col & 0xf0) << 4 | (col & 0xf0) << 8 |\r\n\t\t\t(col & 0xf00) << 8 | (col & 0xf00) << 12 |\r\n\t\t\t(col & 0xf000) << 12 | (col & 0xf000) << 16);\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a color, always in 32-bit RGBA format.\r\n\t * @param col {number|string} either a 12-bit number (0xrgb0), a 32-bit number (0xaabbggrr)\r\n\t * or a string (#rgb, #rrggbb, #rrggbbaa).\r\n\t * @returns {number} the color in 32-bit RGBA format.\r\n\t */\r\n\tstatic parse(col: string|number): number {\r\n\t\tif (typeof col === 'string') {\r\n\t\t\tif (col.charAt(0) !== '#') col = ''; // fail\r\n\r\n\t\t\t// Invert byte order\r\n\t\t\tswitch (col.length) {\r\n\t\t\tcase 4:\r\n\t\t\t\tcol = parseInt(col.substring(1), 16);\r\n\t\t\t\treturn color32.extendColor12(col << 4 | 0xf);\r\n\t\t\tcase 5:\r\n\t\t\t\tcol = parseInt(col.substring(1), 16);\r\n\t\t\t\treturn color32.extendColor12(col);\r\n\t\t\tcase 7:\r\n\t\t\t\tcol = parseInt(col.substring(1), 16);\r\n\t\t\t\t// Pass a RGBA with alpha=ff\r\n\t\t\t\treturn color32.reverseColor32(col << 8 | 0xff);\r\n\t\t\tcase 9:\r\n\t\t\t\tcol = parseInt(col.substring(1), 16);\r\n\t\t\t\treturn color32.reverseColor32(col);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Invalid color string ${col}`);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (col <= 0xffff) {\r\n\t\t\t// 16-bit to 32\r\n\t\t\treturn color32.extendColor12(col);\r\n\t\t}\r\n\t\telse if (col <= 0xffffff) {\r\n\t\t\t// 24-bit to 32\r\n\t\t\treturn col | 0xff << 24;\r\n\t\t}\r\n\t\treturn col;\r\n\t}\r\n\r\n\t/**\r\n\t * @param c {number} color to affect\r\n\t * @param bitsPerComponent {number} can be 2, 3, 4, 5 to return a reduced color value (x bits per component)\r\n\t */\r\n\tstatic posterize(c: number, bitsPerComponent: number) {\r\n\t\tif (bitsPerComponent === 2) {\r\n\t\t\tlet hiBits = (c >>> 6 & 0x01010101) | (c >>> 7 & 0x01010101);\r\n\t\t\thiBits |= hiBits << 1;\r\n\t\t\tc = c >>> 6 & 0x03030303;\r\n\t\t\treturn hiBits | hiBits << 2 | c << 4 | c << 6;\r\n\t\t} else if (bitsPerComponent === 3) {\r\n\t\t\tconst hiBits = c >>> 6 & 0x03030303;\r\n\t\t\tc = (c >>> 5 & 0x07070707);\r\n\t\t\treturn c | c << 5 | c << 2 | hiBits;\r\n\t\t} else if (bitsPerComponent === 4) {\r\n\t\t\tc = (c >>> 4 & 0x0f0f0f0f);\r\n\t\t\treturn c | c << 4;\r\n\t\t} else if (bitsPerComponent === 5) {\r\n\t\t\tconst hiBits = (c >>> 5 & 0x07070707);\r\n\t\t\tc = (c >>> 3 & 0x1f1f1f1f);\r\n\t\t\treturn c | c << 3 | hiBits;\r\n\t\t}\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * Reverses the byte order of a RGBA color.\r\n\t * @param col {number}\r\n\t * @returns {number}\r\n\t */\r\n\tstatic reverseColor32(col: number): number {\r\n\t\treturn (col & 0xff) << 24 | (col >>> 8 & 0xff) << 16 | (col >>> 16 & 0xff) << 8 | (col >>> 24 & 0xff);\r\n\t}\r\n\r\n\tstatic add(c: number, d: number): number {\r\n\t\tlet a = (c >>> 24) + (d >>> 24);\r\n\t\tlet b = ((c >>> 16) & 0xff) + ((d >>> 16) & 0xff);\r\n\t\tlet g = ((c >>> 8) & 0xff) + ((d >>> 8) & 0xff);\r\n\t\tlet r = (c & 0xff) + (d & 0xff);\r\n\t\tif (a > 255) a = 255;\r\n\t\tif (b > 255) b = 255;\r\n\t\tif (g > 255) g = 255;\r\n\t\tif (r > 255) r = 255;\r\n\t\treturn r | g << 8 | b << 16 | a << 24;\r\n\t}\r\n\r\n\tstatic sub(c: number, d: number): number {\r\n\t\tlet a = (c >>> 24) - (d >>> 24);\r\n\t\tlet b = ((c >>> 16) & 0xff) - ((d >>> 16) & 0xff);\r\n\t\tlet g = ((c >>> 8) & 0xff) - ((d >>> 8) & 0xff);\r\n\t\tlet r = (c & 0xff) - (d & 0xff);\r\n\t\tif (a < 0) a = 0;\r\n\t\tif (b < 0) b = 0;\r\n\t\tif (g < 0) g = 0;\r\n\t\tif (r < 0) r = 0;\r\n\t\treturn r | g << 8 | b << 16 | a << 24;\r\n\t}\r\n\r\n\tstatic mul(c: number, d: number): number {\r\n\t\tlet a = ((c >>> 24) * (d >>> 24)) / 255;\r\n\t\tlet b = ((c >>> 16) & 0xff) * ((d >>> 16) & 0xff) / 255;\r\n\t\tlet g = ((c >>> 8) & 0xff) * ((d >>> 8) & 0xff) / 255;\r\n\t\tlet r = (c & 0xff) * (d & 0xff) / 255;\r\n\t\treturn r | g << 8 | b << 16 | a << 24;\r\n\t}\r\n\r\n\tstatic blend(c: number, d: number, factor: number): number {\r\n\t\tfactor = Math.min(1, Math.max(0, factor));\r\n\t\tconst invF = 1 - factor;\r\n\r\n\t\tconst a = (c >>> 24) * invF + (d >>> 24) * factor;\r\n\t\tconst b = ((c >>> 16) & 0xff) * invF + ((d >>> 16) & 0xff) * factor;\r\n\t\tconst g = ((c >>> 8) & 0xff) * invF + ((d >>> 8) & 0xff) * factor;\r\n\t\tconst r = (c & 0xff) * invF + (d & 0xff) * factor;\r\n\t\treturn r | g << 8 | b << 16 | a << 24;\r\n\t}\r\n}\r\n","import { LoadedTexture, readFromTexture32 } from \"./utils\";\r\nimport { color32 } from './color32';\r\n\r\n/**\r\n * Typed buffer that represents a texture stored in RAM. Contrary to the OpenGL textures, the type doesn't need to be\r\n * 32-bit integers. You may pass 8, 16 or 32 bit data, and depending on that, you can read/write data with the\r\n * equivalent type.\r\n */\r\nexport class ShadowTexture {\r\n\tpublic readonly buffer: Uint8Array|Uint16Array|Uint32Array;\r\n\tpublic readonly width: number;\r\n\tpublic readonly height: number;\r\n\tprivate readonly pixelsPerTexel: number;\r\n\tprivate posterizeToBpp: number = -1;\r\n\r\n\t/**\r\n\t * @param buffer {Uint8Array|Uint16Array|Uint32Array} original texture to construct this shadow texture from (no copy made! use .slice() if required).\r\n\t * @param width {number} width of the original texture (in texels)\r\n\t * @param height {number} height of this texture (in texels)\r\n\t * @param pixelsPerTexel {number}\r\n\t */\r\n\tconstructor(buffer: Uint8Array|Uint16Array|Uint32Array, width: number, height: number, pixelsPerTexel: number) {\r\n\t\t/** @type {Uint8Array|Uint16Array|Uint32Array} */\r\n\t\tthis.buffer = buffer;\r\n\t\t/** @type {number} */\r\n\t\tthis.width = width;\r\n\t\t/** @type {number} */\r\n\t\tthis.height = height;\r\n\t\t/** @type {number} */\r\n\t\tthis.pixelsPerTexel = pixelsPerTexel;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {ShadowTexture} deep copy\r\n\t */\r\n\tclone(): ShadowTexture {\r\n\t\tconst result = new ShadowTexture(this.buffer.slice(0), this.width, this.height, this.pixelsPerTexel);\r\n\t\tresult.posterizeToBpp = this.posterizeToBpp;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Reads a part of the shadow texture in typed units into a buffer (which needs to be of the same type that this\r\n\t * ShadowTexture). The buffer is tightly packed (h lines of w typed elements).\r\n\t */\r\n\treadToBuffer(x: number, y: number, w: number, h: number, result: Uint8Array|Uint16Array|Uint32Array) {\r\n\t\tif (typeof this.buffer !== typeof result) throw new Error('readFromShadowTexture: dest buffer must be of same type');\r\n\r\n\t\tconst texWidth = this.width * this.pixelsPerTexel;\r\n\t\tlet src = x + y * texWidth, dst = 0;\r\n\t\tfor (let i = 0; i < h; i++) {\r\n\t\t\tresult.set(this.buffer.subarray(src, src + w), dst);\r\n\t\t\tsrc += texWidth;\r\n\t\t\tdst += w;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Enables automatic posterization when writing from this ShaowedTexture to the VRAM. You can either pass -1 to\r\n\t * disable it or pass a number of 2, 3, 4 or 5 (meaning that many bits per RGBA component).\r\n\t */\r\n\tsetPosterization(bitsPerPixel: number) {\r\n\t\tif (this.buffer.constructor !== Uint32Array) throw new Error('Posterization only available for color buffers (32-bit)');\r\n\t\tthis.posterizeToBpp = bitsPerPixel;\r\n\t}\r\n\r\n\t/**\r\n\t * Writes data to the shadow texture. The data is tightly a packed buffer (h lines of w typed elements) of the same\r\n\t * type as this ShadowTexture.\r\n\t */\r\n\twriteTo(x, y, w, h, data) {\r\n\t\tif (typeof this.buffer !== typeof data) throw new Error('writeToShadowTexture: data must be of same type');\r\n\r\n\t\tconst texWidth = this.width * this.pixelsPerTexel;\r\n\t\tlet src = 0, dst = x + y * texWidth;\r\n\t\tfor (let i = 0; i < h; i++) {\r\n\t\t\tthis.buffer.set(data.subarray(src, src + w), dst);\r\n\t\t\tsrc += w;\r\n\t\t\tdst += texWidth;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates surrounding pixels accordingly so that the memory write is 32-bit aligned.\r\n\t * @param gl {WebGLRenderingContext}\r\n\t * @param texture {WebGLTexture} destination texture\r\n\t * @param x {number} portion to write (top-left) in texel coordinates (32-bit)\r\n\t * @param y {number} portion to write (top-left) in texel coordinates (32-bit)\r\n\t * @param w {number} number of pixels to write in texels\r\n\t * @param h {number} number of pixels to write in texels\r\n\t */\r\n\tsyncToVramTexture(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, w: number, h: number) {\r\n\t\t// Align width (upper) and x (lower, need an extra column)\r\n\t\tw = Math.ceil(w / this.pixelsPerTexel);\r\n\t\tif (x % this.pixelsPerTexel > 0) w += 1;\r\n\t\tx = Math.floor(x / this.pixelsPerTexel);\r\n\r\n\t\t// TODO Florian -- super inefficient because WebGL 1 doesn't support gl.PACK_ROW_LENGTH, so we have to create a separate buffer\r\n\t\t// The buffer needs to have a stride of w (the width of the sub-image) while we have a buffer with a stride of this.width.\r\n\t\tconst tightlyPackedBuffer = new Uint32Array(w * h);\r\n\t\tconst view = new Uint32Array(this.buffer.buffer);\r\n\t\tconst temp = new ShadowTexture(view, this.width, this.height, 1);\r\n\t\ttemp.readToBuffer(x, y, w, h, tightlyPackedBuffer);\r\n\r\n\t\tif (this.posterizeToBpp >= 1) {\r\n\t\t\tfor (let i = 0; i < tightlyPackedBuffer.length; i++) {\r\n\t\t\t\ttightlyPackedBuffer[i] = color32.posterize(tightlyPackedBuffer[i], this.posterizeToBpp);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\t\tgl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(tightlyPackedBuffer.buffer));\r\n\t}\r\n}\r\n\r\nexport function makeShadowFromTexture8(gl: WebGLRenderingContext, tex: LoadedTexture): ShadowTexture {\r\n\tconst typed = new Uint8Array(readFromTexture32(gl, tex.texture, 0, 0, tex.width, tex.height).buffer);\r\n\treturn new ShadowTexture(typed, tex.width, tex.height, 4);\r\n}\r\n\r\nexport function makeShadowFromTexture16(gl: WebGLRenderingContext, tex: LoadedTexture): ShadowTexture {\r\n\tconst typed = new Uint16Array(readFromTexture32(gl, tex.texture, 0, 0, tex.width, tex.height).buffer);\r\n\treturn new ShadowTexture(typed, tex.width, tex.height, 2);\r\n}\r\n\r\nexport function makeShadowFromTexture32(gl: WebGLRenderingContext, tex: LoadedTexture): ShadowTexture {\r\n\tconst typed = new Uint32Array(readFromTexture32(gl, tex.texture, 0, 0, tex.width, tex.height).buffer);\r\n\treturn new ShadowTexture(typed, tex.width, tex.height, 1);\r\n}\r\n","import { createDataTextureFloat, loadTexture, writeToTextureFloat } from \"./utils\";\r\nimport { drawPendingObj, enqueueObj, initObjShaders, makeObjBuffer, ObjBuffer } from \"./sprites\";\r\nimport { drawPendingMap, enqueueMap, initMapShaders, makeMapBuffer } from \"./maps\";\r\nimport {\r\n\tenvColor,\r\n\tOTHER_TEX_W,\r\n\tSCREEN_HEIGHT,\r\n\tSCREEN_WIDTH,\r\n\tSEMITRANSPARENT_CANVAS,\r\n\tsetTextureSizes,\r\n\tUSE_PRIORITIES\r\n} from \"./shaders\";\r\nimport { drawOpaquePoly, initOpaquePolyShaders } from \"./generalpolys\";\r\nimport { Array2D, VdpMap, VdpPalette, VdpSprite } from \"./memory\";\r\nimport {\r\n\tmakeShadowFromTexture16,\r\n\tmakeShadowFromTexture32,\r\n\tmakeShadowFromTexture8,\r\n\tShadowTexture\r\n} from \"./shadowtexture\";\r\nimport { color32 } from \"./color32\";\r\nimport { mat3, mat4 } from 'gl-matrix';\r\n\r\nexport const DEBUG = true;\r\n// Specs of the fantasy console, do not modify for now\r\nconst BG_LIMIT = 4;\r\nconst TBG_LIMIT = 1;\r\nconst OBJ1_CELL_LIMIT = 64;\r\nconst OBJ0_CELL_LIMIT = 256;\r\n\r\ntype TransparencyConfigEffect = 'none' | 'color' | 'blend' | 'premult';\r\ntype TransparencyConfigOperation = 'add' | 'sub';\r\n\r\nclass TransparencyConfig {\r\n\teffect: TransparencyConfigEffect;\r\n\toperation: TransparencyConfigOperation;\r\n\tblendSrc: number;\r\n\tblendDst: number;\r\n\r\n\tconstructor(effect: TransparencyConfigEffect, operation: TransparencyConfigOperation, blendSrc: number, blendDst: number) {\r\n\t\tthis.effect = effect;\r\n\t\tthis.operation = operation;\r\n\t\tthis.blendSrc = blendSrc;\r\n\t\tthis.blendDst = blendDst;\r\n\t}\r\n\r\n\tapply(vdp: VDP) {\r\n\t\tconst gl = vdp.gl;\r\n\t\tconst {effect, blendSrc, blendDst, operation} = this;\r\n\r\n\t\tenvColor[0] = envColor[1] = envColor[2] = envColor[3] = 1;\r\n\t\tgl.blendEquation(operation === 'sub' ? gl.FUNC_REVERSE_SUBTRACT : gl.FUNC_ADD);\r\n\r\n\t\tif (effect === 'blend') { // Used internally for the fade\r\n\t\t\tgl.enable(gl.BLEND);\r\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n\t\t} else if (effect === 'premult') {\r\n\t\t\tgl.enable(gl.BLEND);\r\n\t\t\tgl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n\t\t} else if (effect === 'color') {\r\n\t\t\tconst dst = color32.extract(blendDst, vdp.paletteBpp);\r\n\t\t\tconst src = color32.extract(blendSrc, vdp.paletteBpp);\r\n\t\t\t// Background blend factor\r\n\t\t\tgl.blendColor(dst.r / 255, dst.g / 255, dst.b / 255, dst.a / 255);\r\n\t\t\t// Source blend factor defined in shader\r\n\t\t\tenvColor[0] = src.r / 255;\r\n\t\t\tenvColor[1] = src.g / 255;\r\n\t\t\tenvColor[2] = src.b / 255;\r\n\t\t\tenvColor[3] = src.a / 255;\r\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.CONSTANT_COLOR);\r\n\t\t\tgl.enable(gl.BLEND);\r\n\t\t} else {\r\n\t\t\tgl.disable(gl.BLEND);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport enum VDPCopySource {\r\n\tcurrent,\r\n\trom,\r\n\tblank,\r\n}\r\n\r\n/**\r\n * Use this class to provide a transformation for each line of the BG when drawing. You can create many kind of effects\r\n * using this, look at the samples.\r\n */\r\nexport class LineTransformationArray {\r\n\tbuffer: Float32Array;\r\n\tnumLines: number;\r\n\r\n\tconstructor() {\r\n\t\t// 8 floats per item (hack for the last one since mat3 is actually 9 items)\r\n\t\tthis.numLines = SCREEN_HEIGHT;\r\n\t\tthis.buffer = new Float32Array(this.numLines * 8);\r\n  }\r\n\r\n  getLine(lineNo): mat3 {\r\n\t  if (lineNo < 0 || lineNo >= this.numLines) throw new Error(`getLine: index ${lineNo} out of range`);\r\n\t\treturn mat3.fromValues(this.buffer[lineNo * 8], this.buffer[lineNo * 8 + 1], this.buffer[lineNo * 8 + 2], this.buffer[lineNo * 8 + 3], this.buffer[lineNo * 8 + 4], this.buffer[lineNo * 8 + 5], this.buffer[lineNo * 8 + 6], this.buffer[lineNo * 8 + 7], 1);\r\n  }\r\n\r\n\tsetLine(lineNo, transformation: mat3) {\r\n\t\tif (lineNo < 0 || lineNo >= this.numLines) throw new Error(`setLine: index ${lineNo} out of range`);\r\n\t\tthis.buffer.set((transformation as Float32Array).subarray(0, 8), lineNo * 8);\r\n\t}\r\n}\r\n\r\nconst NO_TRANSPARENCY = new TransparencyConfig('none', 'add', 0, 0);\r\nconst STANDARD_TRANSPARENCY = new TransparencyConfig('blend', 'add', 0, 0);\r\n\r\nexport class VDP {\r\n\tgl: WebGLRenderingContext;\r\n\tgameData: any;\r\n\tmapProgram: any;\r\n\tmodelViewMatrix: mat3;\r\n\tprojectionMatrix: mat4;\r\n\tspriteProgram: any;\r\n\topaquePolyProgram: any;\r\n\tmapTexture: WebGLTexture;\r\n\tpaletteTexture: WebGLTexture;\r\n\tspriteTexture: WebGLTexture;\r\n\totherTexture: WebGLTexture;\r\n\r\n\t// Fade color (factor is the upper 8 bits).\r\n\tprivate fadeColor = 0x00000000;\r\n\tprivate bgTransparency = new TransparencyConfig('color', 'add', 0x888888, 0x888888);\r\n\tprivate objTransparency = new TransparencyConfig('color', 'add', 0x888888, 0x888888);\r\n\tprivate bgBuffer = makeMapBuffer('Opaque BG [BG]', BG_LIMIT);\r\n\tprivate tbgBuffer = makeMapBuffer('Transparent BG [TBG]', TBG_LIMIT);\r\n\tprivate obj0Buffer = makeObjBuffer('Opaque sprites [OBJ0]', 480);\r\n\tprivate obj1Buffer = makeObjBuffer('Transparent sprites [OBJ1]', 32);\r\n\tprivate stats = {\r\n\t\tpeakOBJ0: 0,\r\n\t\tpeakOBJ1: 0,\r\n\t\tpeakBG: 0,\r\n\t\tOBJ0Limit: OBJ0_CELL_LIMIT\r\n\t};\r\n\tprivate frameStarted = true;\r\n\t// 2 = 64 colors (SMS), 3 = 512 colors (Mega Drive), 4 = 4096 (System 16), 5 = 32k (SNES), 8 = unmodified (PC)\r\n\tpublic paletteBpp;\r\n\t// Original data (ROM) for sprites\r\n\tprivate romSpriteTex: ShadowTexture;\r\n\t// Copy of the VRAM data for fast read access from the program\r\n\tprivate shadowSpriteTex: ShadowTexture;\r\n\tprivate romPaletteTex: ShadowTexture;\r\n\tprivate shadowPaletteTex: ShadowTexture;\r\n\tprivate romMapTex: ShadowTexture;\r\n\tprivate shadowMapTex: ShadowTexture;\r\n\tprivate nextLinescrollBuffer: number = 0;\r\n\r\n\tconstructor(canvas: HTMLCanvasElement, done: () => void) {\r\n\t\tthis._initContext(canvas);\r\n\t\tthis._initMatrices();\r\n\r\n\t\tconst gl = this.gl;\r\n\t\t// TODO Florian -- run all requests at the same time and wait for them all.\r\n\t\twindow.fetch('build/game.json').then((res) => res.json()).then((json) => {\r\n\t\t\tthis.gameData = json;\r\n\t\t\tthis.paletteBpp = json.info.paletteBpp;\r\n\t\t\tif ([2, 3, 4, 5, 8].indexOf(this.paletteBpp) === -1) throw new Error(`Unsupported paletteBpp ${this.paletteBpp}`);\r\n\r\n\t\t\tloadTexture(gl, 'build/sprites.png').then(sprites => {\r\n\t\t\t\tthis.spriteTexture = sprites.texture;\r\n\t\t\t\tthis.romSpriteTex = makeShadowFromTexture8(gl, sprites);\r\n\t\t\t\tthis.shadowSpriteTex = this.romSpriteTex.clone();\r\n\r\n\t\t\t\tloadTexture(gl, 'build/palettes.png').then(palettes => {\r\n\t\t\t\t\tif (!(palettes.width === 256 && palettes.height === 64) && !(palettes.width === 16 && palettes.height === 256))\r\n\t\t\t\t\t\tthrow new Error('Mismatch in texture size (max {16,256}x256');\r\n\t\t\t\t\tthis.paletteTexture = palettes.texture;\r\n\t\t\t\t\tthis.romPaletteTex = makeShadowFromTexture32(gl, palettes);\r\n\t\t\t\t\tthis.shadowPaletteTex = this.romPaletteTex.clone();\r\n\t\t\t\t\tif (this.paletteBpp !== 8) this.shadowPaletteTex.setPosterization(this.paletteBpp);\r\n\r\n\t\t\t\t\tloadTexture(gl, 'build/maps.png').then(maps => {\r\n\t\t\t\t\t\tthis.mapTexture = maps.texture;\r\n\t\t\t\t\t\tthis.romMapTex = makeShadowFromTexture16(gl, maps);\r\n\t\t\t\t\t\tthis.shadowMapTex = this.romMapTex.clone();\r\n\r\n\t\t\t\t\t\tsetTextureSizes(palettes.width, palettes.height, maps.width, maps.height, sprites.width, sprites.height);\r\n\r\n\t\t\t\t\t\tthis.otherTexture = createDataTextureFloat(gl, OTHER_TEX_W, OTHER_TEX_W);\r\n\t\t\t\t\t\t// Startup color\r\n\t\t\t\t\t\tthis.configBDColor('#008');\r\n\r\n\t\t\t\t\t\tinitMapShaders(this);\r\n\t\t\t\t\t\tinitObjShaders(this);\r\n\t\t\t\t\t\tinitOpaquePolyShaders(this);\r\n\t\t\t\t\t\tdone();\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Configures the backdrop (background color that is always present).\r\n\t * Note that the backdrop is exactly the first color of the first palette. You can therefore modify it by writing\r\n\t * to that palette color too. It can become handy when you are doing fades by modifying all colors.\r\n\t * @param color backdrop color\r\n\t */\r\n\tconfigBDColor(color: number|string) {\r\n\t\tthis.shadowPaletteTex.buffer[0] = color32.parse(color);\r\n\t}\r\n\r\n\t/**\r\n\t * Configure transparent background effect.\r\n\t * @param opts\r\n\t * @param opts.op 'add' or 'sub'\r\n\t * @param opts.blendSrc source tint (quantity of color to take from the blending object)\r\n\t * @param opts.blendDst destination tint (quantity of color to take from the backbuffer when mixing)\r\n\t */\r\n\tconfigBGTransparency(opts: {op: TransparencyConfigOperation, blendSrc: number|string, blendDst: number|string}) {\r\n\t\tif (opts.op !== 'add' && opts.op !== 'sub') {\r\n\t\t\tthrow new Error(`Invalid operation ${opts.op}`);\r\n\t\t}\r\n\t\tthis.bgTransparency.operation = opts.op;\r\n\t\tthis.bgTransparency.blendSrc = color32.parse(opts.blendSrc);\r\n\t\tthis.bgTransparency.blendDst = color32.parse(opts.blendDst);\r\n\t}\r\n\r\n\t/**\r\n\t * Configures the fade.\r\n\t * @param color destination color (suggested black or white).\r\n\t * @param factor between 0 and 255. 0 means disabled, 255 means fully covered. The fade is only visible in\r\n\t * increments of 16 (i.e. 1-15 is equivalent to 0).\r\n\t */\r\n\tconfigFade(color: number|string, factor: number) {\r\n\t\tfactor = Math.min(255, Math.max(0, factor));\r\n\t\tthis.fadeColor = (color32.parse(color) & 0xffffff) | (factor << 24);\r\n\t}\r\n\r\n\t/**\r\n\t * Configure effect for transparent sprites.\r\n\t * @param opts\r\n\t * @param opts.op 'add' or 'sub'\r\n\t * @param opts.blendSrc source tint (quantity of color to take from the blending object)\r\n\t * @param opts.blendDst destination tint (quantity of color to take from the backbuffer when mixing)\r\n\t */\r\n\tconfigOBJTransparency(opts: {op: TransparencyConfigOperation, blendSrc: number|string, blendDst: number|string}) {\r\n\t\tif (opts.op !== 'add' && opts.op !== 'sub') {\r\n\t\t\tthrow new Error(`Invalid operation ${opts.op}`);\r\n\t\t}\r\n\t\tthis.objTransparency.operation = opts.op;\r\n\t\tthis.objTransparency.blendSrc = color32.parse(opts.blendSrc);\r\n\t\tthis.objTransparency.blendDst = color32.parse(opts.blendDst);\r\n\t}\r\n\r\n\t/**\r\n\t * @param map map to draw (e.g. vdp.map('level1') or just 'level1')\r\n\t * @param [opts]\r\n\t * @param opts.palette specific base palette to use (for the normal tiles). Keep in mind that individual map tiles may use the next 15 palettes by setting the bits 12-15 of the tile number.\r\n\t * @param opts.scrollX horizontal scrolling\r\n\t * @param opts.scrollY vertical scrolling\r\n\t * @param opts.winX left coordinate on the screen to start drawing from (default to 0)\r\n\t * @param opts.winY top coordinate on the screen to start drawing from (default to 0)\r\n\t * @param opts.winW width after which to stop drawing (defaults to SCREEN_WIDTH)\r\n\t * @param opts.winH height after which to stop drawing (defaults to SCREEN_HEIGHT)\r\n\t * @param opts.lineTransform {LineTransformationArray} per-line transformation array\r\n\t * @param opts.wrap whether to wrap the map at the bounds (defaults to true)\r\n\t * @param opts.tileset custom tileset to use.\r\n\t * @param opts.transparent\r\n\t * @param opts.prio z-order\r\n\t */\r\n\tdrawBG(map, opts: {palette?: string|VdpPalette, scrollX?: number, scrollY?: number, winX?: number, winY?: number, winW?: number, winH?: number, lineTransform?: LineTransformationArray, wrap?: boolean, tileset?: string|VdpSprite, transparent?: boolean, prio?: number} = {}) {\r\n\t\tif (typeof map === 'string') map = this.map(map);\r\n\t\t// TODO Florian -- no need for such a param, since the user can modify map.designPalette himself\r\n\t\t// Maybe the other options could be in the map too (just beware that they are strings, not actual links to the palette/tileset but we could typecheck too)\r\n\t\tconst pal = this._getPalette(opts.hasOwnProperty('palette') ? opts.palette : map.designPalette);\r\n\t\tconst til = this._getSprite(opts.hasOwnProperty('tileset') ? opts.tileset : map.designTileset);\r\n\t\tconst scrollX = opts.hasOwnProperty('scrollX') ? opts.scrollX : 0;\r\n\t\tconst scrollY = opts.hasOwnProperty('scrollY') ? opts.scrollY : 0;\r\n\t\tlet winX = opts.hasOwnProperty('winX') ? opts.winX : 0;\r\n\t\tlet winY = opts.hasOwnProperty('winY') ? opts.winY : 0;\r\n\t\tlet winW = opts.hasOwnProperty('winW') ? opts.winW : (SCREEN_WIDTH - winX);\r\n\t\tlet winH = opts.hasOwnProperty('winH') ? opts.winH : (SCREEN_HEIGHT - winY);\r\n\t\tconst wrap = opts.hasOwnProperty('wrap') ? opts.wrap : true;\r\n\t\tconst prio = opts.prio || 0;\r\n\t\tconst buffer = opts.transparent ? this.tbgBuffer : this.bgBuffer;\r\n\r\n\t\tif (this.bgBuffer.usedLayers + this.tbgBuffer.usedLayers >= BG_LIMIT) {\r\n\t\t\tif (DEBUG) console.log(`Too many BGs (${this.bgBuffer.usedLayers} opaque, ${this.tbgBuffer.usedLayers} transparent), ignoring drawBG`);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// To avoid drawing too big quads and them counting toward the BG pixel budget\r\n\t\twinX = Math.min(SCREEN_WIDTH, Math.max(0, winX));\r\n\t\twinY = Math.min(SCREEN_HEIGHT, Math.max(0, winY));\r\n\t\twinW = Math.min(SCREEN_WIDTH - winX, Math.max(0, winW));\r\n\t\twinH = Math.min(SCREEN_HEIGHT - winY, Math.max(0, winH));\r\n\r\n\t\tlet linescrollBuffer = -1;\r\n\t\tif (opts.lineTransform) {\r\n\t\t\tlinescrollBuffer = 256 + this.nextLinescrollBuffer;\r\n\t\t\twriteToTextureFloat(this.gl, this.otherTexture, 0, this.nextLinescrollBuffer++, opts.lineTransform.buffer.length / 4, 1, opts.lineTransform.buffer);\r\n\t\t}\r\n\r\n\t\tenqueueMap(buffer, map.x, map.y, til.x, til.y, map.w, map.h, til.w, til.tw, til.th, winX, winY, winW, winH, scrollX, scrollY, pal.y, til.hiColor, linescrollBuffer, wrap ? 1 : 0, prio);\r\n\t}\r\n\r\n\t/**\r\n\t * @param sprite {string|VdpSprite} sprite to draw (e.g. vdp.sprite('plumber') or just 'plumber')\r\n\t * @param x position (X coord)\r\n\t * @param y position (Y coord)\r\n\t * @param [opts]\r\n\t * @param opts.palette specific palette to use (otherwise just uses the design palette of the sprite)\r\n\t * @param opts.width width on the screen (stretches the sprite compared to sprite.w)\r\n\t * @param opts.height height on the screen (stretches the sprite compared to sprite.h)\r\n\t * @param opts.prio priority of the sprite. By default sprites have a priority of 1 (whereas BGs use 0). Note\r\n\t * that a sprite having the same priority as a BG will appear BEHIND the BG. This allows you to hide objects behind\r\n\t * background planes.\r\n\t * @param opts.transparent whether this is a OBJ1 type sprite (with color effects)\r\n\t */\r\n\tdrawObj(sprite, x, y, opts: {palette?: string|VdpPalette, width?: number, height?: number, prio?: number, transparent?: boolean} = {}) {\r\n\t\tif (typeof sprite === 'string') sprite = this.sprite(sprite);\r\n\t\t// TODO Florian -- no need for such a param, since the user can modify sprite.designPalette himself\r\n\t\tconst pal = this._getPalette(opts.hasOwnProperty('palette') ? opts.palette : sprite.designPalette);\r\n\t\tconst w = opts.hasOwnProperty('width') ? opts.width : sprite.w;\r\n\t\tconst h = opts.hasOwnProperty('height') ? opts.height : sprite.h;\r\n\t\tconst prio = opts.prio || 1;\r\n\t\tconst buffer = opts.transparent ? this.obj1Buffer: this.obj0Buffer;\r\n\r\n\t\tenqueueObj(buffer, x, y, x + w, y + h, sprite.x, sprite.y, sprite.x + sprite.w, sprite.y + sprite.h, pal.y, sprite.hiColor, prio);\r\n\t}\r\n\r\n\t/**\r\n\t * Get and reset the VDP stats.\r\n\t */\r\n\tgetStats() {\r\n\t\tconst result = this.stats;\r\n\t\tthis.stats = {\r\n\t\t\tpeakOBJ0: 0,\r\n\t\t\tpeakOBJ1: 0,\r\n\t\t\tpeakBG: 0,\r\n\t\t\tOBJ0Limit: OBJ0_CELL_LIMIT\r\n\t\t};\r\n\t\treturn result;\r\n\t}\r\n\r\n\tmap(name: string): VdpMap {\r\n\t\tconst map = this.gameData.maps[name];\r\n\t\tif (!map) throw new Error(`Map ${name} not found`);\r\n\t\treturn new VdpMap(map.x, map.y, map.w, map.h, map.til, map.pal);\r\n\t}\r\n\r\n\tpalette(name: string): VdpPalette {\r\n\t\tconst pal = this.gameData.pals[name];\r\n\t\tif (!pal) throw new Error(`Palette ${name} not found`);\r\n\t\treturn new VdpPalette(pal.y, pal.w, pal.h);\r\n\t}\r\n\r\n\t/**\r\n\t * @param map name of the map (or map itself). You may also query an arbitrary portion of the map\r\n\t * memory using new VdpMap() or offset an existing map, using vdp.map('myMap').offsetted().\r\n\t * @param source set to vdp.SOURCE_BLANK if you don't care about the current content of\r\n\t * the memory (you're going to write only and you need a buffer for that), vdp.SOURCE_CURRENT to read the current\r\n\t * contents of the memory (as was written the last time with writeMap) or vdp.SOURCE_ROM to get the original data\r\n\t * as downloaded from the cartridge.\r\n\t * @return a Array2D containing the map data (buffer member is a Uint16Array), each element being the tile number\r\n\t * in the tileset.\r\n\t */\r\n\treadMap(map: string|VdpMap, source = VDPCopySource.current): Array2D {\r\n\t\tconst m = this._getMap(map);\r\n\t\tconst result = new Uint16Array(m.w * m.h);\r\n\t\tif (source === VDPCopySource.current) this.shadowMapTex.readToBuffer(m.x, m.y, m.w, m.h, result);\r\n\t\tif (source === VDPCopySource.rom) this.romMapTex.readToBuffer(m.x, m.y, m.w, m.h, result);\r\n\t\treturn new Array2D(result, m.w, m.h);\r\n\t}\r\n\r\n\t/**\r\n\t * @param palette name of the palette (or palette itself). You may also query an arbitrary portion\r\n\t * of the palette memory using new VdpPalette() or offset an existing map, using vdp.map('myMap').offsetted().\r\n\t * @param source look at readMap for more info.\r\n\t * @return {Array2D} an array containing the color entries, encoded as 0xAABBGGRR\r\n\t */\r\n\treadPalette(palette: string|VdpPalette, source = VDPCopySource.current): Array2D {\r\n\t\tconst pal = this._getPalette(palette);\r\n\t\treturn this.readPaletteMemory(0, pal.y, pal.w, pal.h, source);\r\n\t}\r\n\r\n\t/**\r\n\t * @param x\r\n\t * @param y\r\n\t * @param w\r\n\t * @param h\r\n\t * @param source look at readMap for more info.\r\n\t * @return a Array2D that contains color entries, encoded as 0xAABBGGRR\r\n\t */\r\n\treadPaletteMemory(x: number, y: number, w: number, h: number, source = VDPCopySource.current): Array2D {\r\n\t\tconst result = new Uint32Array(w * h);\r\n\t\tif (source === VDPCopySource.current) this.shadowPaletteTex.readToBuffer(x, y, w, h, result);\r\n\t\tif (source === VDPCopySource.rom) this.romPaletteTex.readToBuffer(x, y, w, h, result);\r\n\t\treturn new Array2D(result, w, h);\r\n\t}\r\n\r\n\t/**\r\n\t * @param sprite name of the sprite (or sprite itself). You may also query an arbitrary portion of the\r\n\t * sprite memory using new VdpSprite() or offset an existing sprite, using vdp.sprite('mySprite').offsetted().\r\n\t * @param source look at readMap for more info.\r\n\t * @return a Array2D containing the tileset data. For hi-color sprites, each entry represents one pixel.\r\n\t * For lo-color sprites, each entry corresponds to two packed pixels, of 4 bits each.\r\n\t */\r\n\treadSprite(sprite: string|VdpSprite, source = VDPCopySource.current): Array2D {\r\n\t\tconst s = this._getSprite(sprite);\r\n\r\n\t\tif (!s.hiColor && s.x % 2 !== 0) throw new Error('Lo-color sprites need to be aligned to 2 pixels');\r\n\t\tconst x = s.hiColor ? s.x : (s.x / 2);\r\n\t\tconst w = s.hiColor ? s.w : Math.ceil(s.w / 2);\r\n\r\n\t\tconst result = new Uint8Array(w * s.h);\r\n\t\tif (source === VDPCopySource.current) this.shadowSpriteTex.readToBuffer(x, s.y, w, s.h, result);\r\n\t\tif (source === VDPCopySource.rom) this.romSpriteTex.readToBuffer(x, s.y, w, s.h, result);\r\n\t\treturn new Array2D(result, w, s.h);\r\n\t}\r\n\r\n\tsprite(name: string): VdpSprite {\r\n\t\tconst spr = this.gameData.sprites[name];\r\n\t\tif (!spr) throw new Error(`Sprite ${name} not found`);\r\n\t\treturn new VdpSprite(spr.x, spr.y, spr.w, spr.h, spr.tw, spr.th, spr.tiles, spr.hicol, spr.pal);\r\n\t}\r\n\r\n\t/**\r\n\t * @param map {string|VdpMap} name of the map (or map itself). You may also write to an arbitrary portion of the map\r\n\t * memory using new VdpMap() or offset an existing map, using vdp.map('myMap').offsetted().\r\n\t * @param data {Array2D} map data to write (use readMap to create a buffer like that)\r\n\t */\r\n\twriteMap(map: string|VdpMap, data: Array2D) {\r\n\t\tconst m = this._getMap(map);\r\n\t\tthis.shadowMapTex.writeTo(m.x, m.y, m.w, m.h, data.buffer);\r\n\t\tthis.shadowMapTex.syncToVramTexture(this.gl, this.mapTexture, m.x, m.y, m.w, m.h);\r\n\t}\r\n\r\n\t/**\r\n\t * @param palette\r\n\t * @param data {Array2D} color entries, encoded as 0xAABBGGRR\r\n\t */\r\n\twritePalette(palette: string|VdpPalette, data: Array2D) {\r\n\t\tconst pal = this._getPalette(palette);\r\n\t\tthis.writePaletteMemory(0, pal.y, pal.w, pal.h, data);\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param x\r\n\t * @param y\r\n\t * @param w\r\n\t * @param h\r\n\t * @param data {Array2D} color entries, encoded as 0xAABBGGRR\r\n\t */\r\n\twritePaletteMemory(x: number, y: number, w: number, h: number, data: Array2D) {\r\n\t\tthis.shadowPaletteTex.writeTo(x, y, w, h, data.buffer);\r\n\t\tthis.shadowPaletteTex.syncToVramTexture(this.gl, this.paletteTexture, x, y, w, h);\r\n\t}\r\n\r\n\t/**\r\n\t * @param sprite name of the sprite (or sprite itself). You may also write to an arbitrary portion\r\n\t * of the sprite memory using new VdpSprite() or offset an existing sprite, using vdp.sprite('mySprite').offsetted().\r\n\t * @param data {Array2D} the new data. For hi-color sprites, each entry represents one pixel. For lo-color sprites,\r\n\t * each entry corresponds to two packed pixels, of 4 bits each.\r\n\t */\r\n\twriteSprite(sprite: string|VdpSprite, data: Array2D) {\r\n\t\tconst s = this._getSprite(sprite);\r\n\r\n\t\tif (!s.hiColor && s.x % 2 !== 0) throw new Error('Lo-color sprites need to be aligned to 2 pixels');\r\n\t\tconst x = s.hiColor ? s.x : (s.x / 2);\r\n\t\tconst w = s.hiColor ? s.w : Math.ceil(s.w / 2);\r\n\r\n\t\tthis.shadowSpriteTex.writeTo(x, s.y, w, s.h, data.buffer);\r\n\t\tthis.shadowSpriteTex.syncToVramTexture(this.gl, this.paletteTexture, x, s.y, w, s.h);\r\n\t}\r\n\r\n\t// --------------------- PRIVATE ---------------------\r\n\r\n\t// Take one frame in account for the stats. Read with _readStats.\r\n\tprivate _computeStats(obj0Limit: number) {\r\n\t\tthis.stats.peakBG = Math.max(this.stats.peakBG, this.bgBuffer.usedLayers + this.tbgBuffer.usedLayers);\r\n\t\tthis.stats.peakOBJ0 = Math.max(this.stats.peakOBJ0, this._totalUsedOBJ0());\r\n\t\tthis.stats.peakOBJ1 = Math.max(this.stats.peakOBJ1, this._totalUsedOBJ1());\r\n\t\tthis.stats.OBJ0Limit = Math.min(this.stats.OBJ0Limit, obj0Limit);\r\n\t}\r\n\r\n\t/**\r\n\t * Renders the machine in the current state. Only available for the extended version of the GPU.\r\n\t */\r\n\tprivate _doRender() {\r\n\t\tconst gl = this.gl;\r\n\t\t// Do before drawing stuff since it flushes the buffer\r\n\t\tif (DEBUG) this._computeStats(OBJ0_CELL_LIMIT);\r\n\r\n\t\t// Only the first time per frame (allow multiple render per frames)\r\n\t\tif (this.frameStarted) {\r\n\t\t\tconst clearColor = color32.extract(this.shadowPaletteTex.buffer[0], this.paletteBpp);\r\n\t\t\tgl.clearColor(clearColor.r / 255, clearColor.g / 255, clearColor.b / 255, 0);\r\n\r\n\t\t\tif (USE_PRIORITIES) {\r\n\t\t\t\tgl.clearDepth(1.0);\t\t\t\t // Clear everything\r\n\t\t\t\t// PERF: This is a lot slower if there's a discard in the fragment shader (and we need one?) because the GPU can't test & write to the depth buffer until after the fragment shader has been executed. So there's no point in using it I guess.\r\n\t\t\t\tgl.enable(gl.DEPTH_TEST);\t\t   // Enable depth testing\r\n\t\t\t\tgl.depthFunc(gl.LESS);\t\t\t// Near things obscure far things\r\n\t\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\r\n\t\t\t}\r\n\r\n\t\t\tthis.frameStarted = false;\r\n\t\t}\r\n\r\n\t\t// OBJ0 and BG (both opaque, OBJ0 first to appear above\r\n\t\tNO_TRANSPARENCY.apply(this);\r\n\t\tmat3.identity(this.modelViewMatrix);\r\n\t\tdrawPendingMap(this, this.bgBuffer);\r\n\t\tthis._drawObjLayer(this.obj0Buffer, OBJ0_CELL_LIMIT);\r\n\r\n\t\t// TBG then OBJ1\r\n\t\tthis.bgTransparency.apply(this);\r\n\t\tgl.depthMask(false);\r\n\t\tdrawPendingMap(this, this.tbgBuffer);\r\n\t\tgl.depthMask(true);\r\n\r\n\t\t// Draw in reverse order\r\n\t\tthis.obj1Buffer.sort();\r\n\t\tthis.objTransparency.apply(this);\r\n\t\tthis._drawObjLayer(this.obj1Buffer, OBJ1_CELL_LIMIT);\r\n\r\n\t\tthis.nextLinescrollBuffer = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @param objBuffer {ObjBuffer}\r\n\t * @param objLimit {number} max number of cells drawable\r\n\t * @private\r\n\t */\r\n\tprivate _drawObjLayer(objBuffer: ObjBuffer, objLimit: number = 0) {\r\n\t\t// Use config only for that poly list\r\n\t\tmat3.identity(this.modelViewMatrix);\r\n\t\tdrawPendingObj(this, objBuffer, objLimit);\r\n\t\tmat3.identity(this.modelViewMatrix);\r\n\t}\r\n\r\n\tpublic _endFrame() {\r\n\t\tthis._doRender();\r\n\r\n\t\t// Draw fade\r\n\t\tif (this.fadeColor >>> 24 >= 0x10) {\r\n\t\t\tconst gl = this.gl;\r\n\t\t\tconst {r, g, b, a} = color32.extract(this.fadeColor, this.paletteBpp);\r\n\r\n\t\t\tSTANDARD_TRANSPARENCY.apply(this);\r\n\t\t\tgl.disable(gl.DEPTH_TEST);\r\n\t\t\tdrawOpaquePoly(this, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, r / 255, g / 255, b / 255, a / 255);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _getMap(name: string|VdpMap): VdpMap {\r\n\t\tif (typeof name === 'string') return this.map(name);\r\n\t\treturn name;\r\n\t}\r\n\r\n\tprivate _getPalette(name: string|VdpPalette): VdpPalette {\r\n\t\tif (typeof name === 'string') return this.palette(name);\r\n\t\treturn name;\r\n\t}\r\n\r\n\tprivate _getSprite(name: string|VdpSprite): VdpSprite {\r\n\t\tif (typeof name === 'string') return this.sprite(name);\r\n\t\treturn name;\r\n\t}\r\n\r\n\tprivate _initContext(canvas: HTMLCanvasElement) {\r\n\t\tthis.gl = canvas.getContext(\"webgl\", { premultipliedAlpha: true, alpha: SEMITRANSPARENT_CANVAS });\r\n\r\n\t\t// Only continue if WebGL is available and working\r\n\t\tif (this.gl === null) {\r\n\t\t\talert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _initMatrices() {\r\n\t\tthis.projectionMatrix = mat4.create();\r\n\t\t// note: glmatrix.js always has the first argument as the destination to receive the result.\r\n\t\tmat4.ortho(this.projectionMatrix, 0.0, SCREEN_WIDTH, SCREEN_HEIGHT, 0.0, -10, 10);\r\n\r\n\t\t// Normally set in modelViewMatrix, but we want to allow an empty model view matrix\r\n\t\t//mat4.translate(this.projectionMatrix, this.projectionMatrix, [-0.0, 0.0, -0.1]);\r\n\r\n\t\tthis.modelViewMatrix = mat3.create();\r\n\t\t// mat4.translate(this.modelViewMatrix, this.modelViewMatrix, [-0.0, 0.0, -0.1]);\r\n\t}\r\n\r\n\tpublic _startFrame() {\r\n\t\tthis.frameStarted = true;\r\n\t}\r\n\r\n\tprivate _totalUsedOBJ0(): number {\r\n\t\treturn this.obj0Buffer.computeUsedObjects();\r\n\t}\r\n\r\n\tprivate _totalUsedOBJ1(): number {\r\n\t\treturn this.obj1Buffer.computeUsedObjects();\r\n\t}\r\n}\r\n","import {initShaderProgram, makeBuffer} from \"./utils\";\r\nimport { VDP } from './vdp';\r\n\r\n// For debugging only\r\nexport function initOpaquePolyShaders(vdp: VDP) {\r\n\tconst gl = vdp.gl;\r\n\t// Vertex shader program\r\n\tconst vsSource = `\r\n\t\t\tattribute vec2 aXy;\r\n\t\t\tattribute vec4 aColor;\r\n\t\r\n\t\t\tuniform mat3 uModelViewMatrix;\r\n\t\t\tuniform mat4 uProjectionMatrix;\r\n\t\r\n\t\t\tvarying lowp vec4 vColor;\r\n\t\t\r\n\t\t\tvoid main(void) {\r\n\t\t\t\tgl_Position = uProjectionMatrix * vec4(floor(uModelViewMatrix * vec3(aXy, 0)), 1);\r\n\t\t\t\tvColor = aColor;\r\n\t\t\t}\r\n\t\t`;\r\n\tconst fsSource = `\r\n    varying lowp vec4 vColor;\r\n\r\n    void main(void) {\r\n      gl_FragColor = vColor;\r\n    }\r\n  `;\r\n\r\n\tconst TOTAL_VERTICES = 1 * 4;\r\n\tconst shaderProgram = initShaderProgram(gl, vsSource, fsSource);\r\n\r\n\tvdp.opaquePolyProgram = {\r\n\t\tprogram: shaderProgram,\r\n\t\tarrayBuffers: {\r\n\t\t\txy: new Float32Array(TOTAL_VERTICES * 2),\r\n\t\t\t// TODO Florian -- Use u8 if possible\r\n\t\t\tcolor: new Float32Array(TOTAL_VERTICES * 4)\r\n\t\t},\r\n\t\tattribLocations: {\r\n\t\t\txy: gl.getAttribLocation(shaderProgram, 'aXy'),\r\n\t\t\tcolor: gl.getAttribLocation(shaderProgram, 'aColor'),\r\n\t\t},\r\n\t\tglBuffers: {\r\n\t\t\txy: makeBuffer(gl),\r\n\t\t\tcolor: makeBuffer(gl)\r\n\t\t},\r\n\t\tuniformLocations: {\r\n\t\t\tprojectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n\t\t\tmodelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')\r\n\t\t},\r\n\t};\r\n}\r\n\r\n// Color is float (r, g, b, a) between 0 and 1\r\nexport function drawOpaquePoly(vdp: VDP, xStart: number, yStart: number, xEnd: number, yEnd: number, colorR: number, colorG: number, colorB: number, colorA: number) {\r\n\tconst gl = vdp.gl;\r\n\tconst prog = vdp.opaquePolyProgram;\r\n\tconst positions = [\r\n\t\txStart, yStart,\r\n\t\txEnd, yStart,\r\n\t\txStart, yEnd,\r\n\t\txEnd, yEnd,\r\n\t];\r\n\t// TODO Florian -- use indexed vertices\r\n\tconst colors = [\r\n\t\tcolorR, colorG, colorB, colorA,\r\n\t\tcolorR, colorG, colorB, colorA,\r\n\t\tcolorR, colorG, colorB, colorA,\r\n\t\tcolorR, colorG, colorB, colorA,\r\n\t];\r\n\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xy);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STREAM_DRAW);\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.color);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STREAM_DRAW);\r\n\r\n\tgl.useProgram(prog.program);\r\n\t{\r\n\t\tconst numComponents = 2;  // pull out 4 values per iteration\r\n\t\tconst type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n\t\tconst normalize = false;  // don't normalize\r\n\t\tconst stride = 0;         // how many bytes to get from one set of values to the next\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 0 = use type and numComponents above\r\n\t\tconst offset = 0;         // how many bytes inside the buffer to start from\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.xy);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.xy, numComponents, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.xy);\r\n\t}\r\n\t{\r\n\t\tconst num = 4, type = gl.FLOAT, normalize = false, stride = 0, offset = 0;\r\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, prog.glBuffers.color);\r\n\t\tgl.vertexAttribPointer(prog.attribLocations.color, num, type, normalize, stride, offset);\r\n\t\tgl.enableVertexAttribArray(prog.attribLocations.color);\r\n\t}\r\n\r\n\t// Set the shader uniforms\r\n\tgl.uniformMatrix4fv(prog.uniformLocations.projectionMatrix, false, vdp.projectionMatrix);\r\n\tgl.uniformMatrix3fv(prog.uniformLocations.modelViewMatrix,false, vdp.modelViewMatrix);\r\n\r\n\t{\r\n\t\tconst offset = 0;\r\n\t\tconst vertexCount = 4;\r\n\t\tgl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\r\n\t}\r\n}\r\n\r\n","// Framerate expectations (works OK on a 60 Hz display; if you have a higher resolution display, you may want to set MIN_ACCEPTABLE_DT=REGULAR_DT=MAX_ACCEPTABLE_DT)\r\nexport const NOMINAL_FRAMERATE = 59.94;\r\nconst MIN_ACCEPTABLE_DT = 1 / (NOMINAL_FRAMERATE + 1);\r\nconst REGULAR_DT = 1 / NOMINAL_FRAMERATE;\r\nconst MAX_ACCEPTABLE_DT = 1 / (NOMINAL_FRAMERATE - 1);\r\nconst MAX_LATE = 1 / 4.0;\r\nconst FRAMERATE_SAMPLES = 30;\r\n\r\nexport class FramerateAdjuster {\r\n\tpublic last = 0;\r\n\tpublic late = 0;\r\n\tprivate framerateSum: number = REGULAR_DT * FRAMERATE_SAMPLES;\r\n\r\n\t/**\r\n\t * Strategy that maximizes smoothness on display close to the target framerate.\r\n\t * @param timestamp {number} current timestamp (ms)\r\n\t * @returns {number} the number of frames to render (0..n, the n-1 first should not be rendered).\r\n\t */\r\n\tdoForSmoothness(timestamp: number): number {\r\n\t\tconst diff = this._timeDiff(timestamp);\r\n\t\tthis._addToFramerate(diff);\r\n\r\n\t\tif (diff > MAX_ACCEPTABLE_DT) {\r\n\t\t\tthis.late += diff - MAX_ACCEPTABLE_DT;\r\n\t\t\tif (this.late > MAX_LATE) this.late = 0;\r\n\t\t} else if (diff < MIN_ACCEPTABLE_DT) {\r\n\t\t\tthis.late += diff - MIN_ACCEPTABLE_DT;\r\n\t\t}\r\n\r\n\t\tthis.last = timestamp;\r\n\r\n\t\tif (this.late <= -REGULAR_DT) {\r\n\t\t\tthis.late += REGULAR_DT;\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\tif (this.late >= REGULAR_DT) {\r\n\t\t\t\tconst skipFrames = Math.floor(this.late / REGULAR_DT);\r\n\t\t\t\tthis.late -= skipFrames * REGULAR_DT;\r\n\t\t\t\treturn 1 + skipFrames;\r\n\t\t\t}\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Never skips a frame. Use only if you're very close to the target framerate.\r\n\t * @param timestamp {number} current timestamp (ms)\r\n\t * @returns {number} the number of frames to render (0..n, the n-1 first should not be rendered).\r\n\t */\r\n\tdoSimplest(timestamp: number): number {\r\n\t\tconst diff = this._timeDiff(timestamp);\r\n\t\tthis._addToFramerate(diff);\r\n\t\tthis.last = timestamp;\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Standard frameskipping strategy.\r\n\t * @param timestamp {number}\r\n\t * @returns {number} the number of frames to render (0..n, the n-1 first should not be rendered).\r\n\t */\r\n\tdoStandard(timestamp: number): number {\r\n\t\tconst diff = this._timeDiff(timestamp);\r\n\t\tthis._addToFramerate(diff);\r\n\r\n\t\tthis.late += diff - REGULAR_DT;\r\n\t\tif (this.late > MAX_LATE) this.late = 0;\r\n\t\tthis.last = timestamp;\r\n\r\n\t\tif (this.late >= REGULAR_DT) {\r\n\t\t\tconst skipFrames = Math.floor(this.late / REGULAR_DT);\r\n\t\t\tthis.late -= skipFrames * REGULAR_DT;\r\n\t\t\treturn 1 + skipFrames;\r\n\t\t}\r\n\t\telse if (this.late <= -REGULAR_DT) {\r\n\t\t\tthis.late += REGULAR_DT;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tgetFramerate(): number {\r\n\t\treturn FRAMERATE_SAMPLES / this.framerateSum;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param diff {number}\r\n\t * @private\r\n\t */\r\n\t_addToFramerate(diff: number) {\r\n\t\t// Ignore long breaks\r\n\t\tif (diff < MAX_LATE) {\r\n\t\t\tthis.framerateSum = this.framerateSum * (FRAMERATE_SAMPLES - 1) / FRAMERATE_SAMPLES + diff;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param timestamp {number}\r\n\t * @returns {number}\r\n\t */\r\n\t_timeDiff(timestamp: number): number {\r\n\t\treturn (timestamp - this.last) / 1000;\r\n\t}\r\n}\r\n","import { setParams } from \"./shaders\";\r\nimport { DEBUG, VDP } from \"./vdp\";\r\nimport { FramerateAdjuster, NOMINAL_FRAMERATE } from \"./FramerateAdjuster\";\r\n\r\nexport function loadVdp(canvas: HTMLCanvasElement): Promise<VDP> {\r\n\t//canvas.style.width = `${canvas.width * 2}px`;\r\n\t//canvas.style.height = `${canvas.height * 2}px`;\r\n\tsetParams(canvas.width, canvas.height, false);\r\n\treturn new Promise(function (resolve) {\r\n\t\tconst vdp = new VDP(canvas, () => {\r\n\t\t\tvdp._startFrame();\r\n\t\t\tresolve(vdp);\r\n\t\t});\r\n\t});\r\n}\r\n\r\nexport function runProgram(vdp: VDP, coroutine: IterableIterator<number>) {\r\n\t// All in seconds except last\r\n\tlet lastInt = 0;\r\n\tconst times = [];\r\n\tconst framerateAdj = new FramerateAdjuster();\r\n\tlet renderedFrames = 0, skippedFrames = 0;\r\n\r\n\tfunction step(timestamp) {\r\n\t\tif (DEBUG) {\r\n\t\t\t// Timestamp is in milliseconds\r\n\t\t\tconst timestampInt = Math.floor(timestamp / 1000);\r\n\r\n\t\t\tif (timestampInt !== lastInt && times.length > 0) {\r\n\t\t\t\tconsole.log(`Upd=${(times.reduce((a, b) => a + b) / times.length).toFixed(3)}ms; r=${renderedFrames}, s=${skippedFrames}, u=${times.length}; ${framerateAdj.getFramerate().toFixed(2)}Hz`, vdp.getStats());\r\n\t\t\t\ttimes.length = 0;\r\n\t\t\t\trenderedFrames = skippedFrames = 0;\r\n\t\t\t}\r\n\r\n\t\t\tlastInt = timestampInt;\r\n\t\t}\r\n\r\n\t\t// The algorithm depends on the refresh rate of the screen. Use smooth if close, use simple otherwise as smooth will produce some speed variations.\r\n\t\tconst framerate = framerateAdj.getFramerate();\r\n\t\tlet toRender;\r\n\t\tif (framerate >= NOMINAL_FRAMERATE - 1 && framerate <= NOMINAL_FRAMERATE + 1) {\r\n\t\t\ttoRender = framerateAdj.doSimplest(timestamp);\r\n\t\t} else {\r\n\t\t\ttoRender = framerateAdj.doStandard(timestamp);\r\n\t\t}\r\n\r\n\t\t// Render the expected number of frames\r\n\t\tfor (let i = 0; i < toRender; i++) {\r\n\t\t\tconst before = window.performance.now();\r\n\t\t\tvdp._startFrame();\r\n\t\t\tcoroutine.next();\r\n\t\t\tvdp._endFrame();\r\n\t\t\ttimes.push(window.performance.now() - before);\r\n\t\t}\r\n\r\n\t\tif (DEBUG) {\r\n\t\t\tif (toRender > 0) renderedFrames += 1;\r\n\t\t\tif (toRender > 1) skippedFrames += toRender - 1;\r\n\t\t}\r\n\t\twindow.requestAnimationFrame(step);\r\n\t}\r\n\r\n\twindow.requestAnimationFrame(step);\r\n}\r\n","import { loadVdp, runProgram } from './vdp/runloop';\r\nimport { VDP, LineTransformationArray } from './vdp/vdp';\r\n\r\nexport function startGame(canvas: HTMLCanvasElement, loadedCb: (vdp: VDP) => IterableIterator<number>) {\r\n\tloadVdp(document.querySelector(\"#glCanvas\"))\r\n\t\t.then(vdp => runProgram(vdp, loadedCb(vdp)));\r\n}\r\n\r\nexport {\r\n\tLineTransformationArray\r\n};\r\n"],"sourceRoot":""}